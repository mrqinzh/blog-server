/*
 Navicat Premium Dump SQL

 Source Server         : 127.0.0.1
 Source Server Type    : MySQL
 Source Server Version : 80032 (8.0.32)
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80032 (8.0.32)
 File Encoding         : 65001

 Date: 27/08/2024 20:55:33
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
                           `id` bigint NOT NULL AUTO_INCREMENT,
                           `author` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '文章作者',
                           `title` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '文章标题',
                           `summary` varchar(250) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '文章摘要',
                           `coverImg` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '文章封面图',
                           `updateTime` datetime DEFAULT NULL COMMENT '文章最后修改时间',
                           `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '文章写时的时间',
                           `contentMd` longtext CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci COMMENT '文章内容markdown格式',
                           `tag` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '文章标签',
                           `type` varchar(11) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '文章类型',
                           `views` int NOT NULL DEFAULT '0' COMMENT '文章访问量统计',
                           `userId` bigint NOT NULL,
                           `status` int NOT NULL DEFAULT '0' COMMENT '逻辑删除',
                           PRIMARY KEY (`id`,`userId`) USING BTREE,
                           KEY `user_id` (`userId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=130 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of article
-- ----------------------------
BEGIN;
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (33, '秦志宏', 'Linux', '关于Linux的一些基本使用', NULL, '2021-05-07 11:47:59', '2021-05-07 11:47:59', '## Linux\n\n后台运行 vue 项目\n\n```bash\nnohup npm run dev >/dev/null 2>&1 & exit\n```\n\n', 'linux', '原创', 5, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (34, '秦志宏', ' SpringBoot 文件上传', 'SpringBoot 文件上传', 'http://img.mrqinzh.info/springboot.png', '2021-04-19 00:00:00', '2021-09-17 21:08:52', '## SpringBoot 文件上传\n\n> 创建一个FileController\n\n```java\nimport org.apache.catalina.servlet4preview.http.HttpServletRequest;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.*;\nimport java.util.UUID;\n\n/**\n * 文件上传\n */\n@Controller\npublic class FileController {\n\n    @GetMapping(value = \"/file\")\n    public String file() {\n        return \"file\";\n    }\n\n    @PostMapping(value = \"/fileUpload\")\n    public String fileUpload(@RequestParam(value = \"file\") MultipartFile file, Model model, HttpServletRequest request) {\n        if (file.isEmpty()) {\n            System.out.println(\"文件为空空\");\n        }\n        String fileName = file.getOriginalFilename();  // 文件名\n        String suffixName = fileName.substring(fileName.lastIndexOf(\".\"));  // 后缀名\n        String filePath = \"D://temp-rainy//\"; // 上传后的路径\n        fileName = UUID.randomUUID() + suffixName; // 新文件名\n        File dest = new File(filePath + fileName);\n        if (!dest.getParentFile().exists()) {\n            dest.getParentFile().mkdirs();\n        }\n        try {\n            file.transferTo(dest);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        String filename = \"/temp-rainy/\" + fileName;\n        model.addAttribute(\"filename\", filename);\n        return \"file\";\n    }\n}\n```\n\n> 创建MyWebMvcConfigurer\n\n```java\n/**\n * 资源映射路径\n */\n@Configuration\npublic class MyWebAppConfigurer implements WebMvcConfigurer {\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"/temp-rainy/**\").addResourceLocations(\"file:D:/temp-rainy/\");\n    }\n}\n```\n\n\n\n> jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    <form action=\"/fileUpload\" method=\"post\" enctype=\"multipart/form-data\">\n        <label>上传图片</label>\n        <input type=\"file\" name=\"file\"/>\n        <input type=\"submit\" value=\"上传\"/>\n    </form>\n    <p>图片:</p>\n    <img src=\"${filename }\"/>\n</body>\n</html>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'java,springboot', '原创', 1, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (35, '秦志宏', '个人博客数据库设计', '建表语句', 'http://img.mrqinzh.info/java.png', '2021-04-19 00:00:00', '2021-09-17 21:06:06', '## 个人博客数据库设计\n\n```sql\nCREATE TABLE `zj_users` (\n\n `user_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'用户ID\',\n\n `user_ip` varchar(20) NOT NULL COMMENT \'用户IP\',\n\n `user_name` varchar(20) NOT NULL COMMENT \'用户名\',\n\n `user_password` varchar(15) NOT NULL COMMENT \'用户密码\',\n\n `user_email` varchar(30) NOT NULL COMMENT \'用户邮箱\',\n\n `user_profile_photo` varchar(255) NOT NULL COMMENT \'用户头像\',\n\n `user_registration_time` datetime DEFAULT NULL COMMENT \'注册时间\',\n\n `user_birthday` date DEFAULT NULL COMMENT \'用户生日\',\n\n `user_age` tinyint(4) DEFAULT NULL COMMENT \'用户年龄\',\n\n `user_telephone_number` int(11) NOT NULL COMMENT \'用户手机号\',\n\n `user_nickname` varchar(20) NOT NULL COMMENT \'用户昵称\',\n\n PRIMARY KEY (`user_id`),\n\n KEY `user_name` (`user_name`),\n\n KEY `user_nickname` (`user_nickname`),\n\n KEY `user_email` (`user_email`),\n\n KEY `user_telephone_number` (`user_telephone_number`)\n\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\n\nCREATE TABLE `zj_articles` (\n\n `article_id` bigint(255) NOT NULL AUTO_INCREMENT COMMENT \'博文ID\',\n\n `user_id` bigint(20) NOT NULL COMMENT \'发表用户ID\',\n\n `article_title` text NOT NULL COMMENT \'博文标题\',\n\n `article_content` longtext NOT NULL COMMENT \'博文内容\',\n\n `article_views` bigint(20) NOT NULL COMMENT \'浏览量\',\n\n `article_comment_count` bigint(20) NOT NULL COMMENT \'评论总数\',\n\n `article_date` datetime DEFAULT NULL COMMENT \'发表时间\',\n\n `article_like_count` bigint(20) NOT NULL,\n\n PRIMARY KEY (`article_id`),\n\n KEY `user_id` (`user_id`),\n\n CONSTRAINT `zj_articles_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `zj_users` (`user_id`)\n\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\n\nCREATE TABLE `zj_comments` (\n\n `comment_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'评论ID\',\n\n `user_id` bigint(20) NOT NULL COMMENT \'发表用户ID\',\n\n `article_id` bigint(20) NOT NULL COMMENT \'评论博文ID\',\n\n `comment_like_count` bigint(20) NOT NULL COMMENT \'点赞数\',\n\n `comment_date` datetime DEFAULT NULL COMMENT \'评论日期\',\n\n `comment_content` text NOT NULL COMMENT \'评论内容\',\n\n `parent_comment_id` bigint(20) NOT NULL COMMENT \'父评论ID\',\n\n PRIMARY KEY (`comment_id`),\n\n KEY `article_id` (`article_id`),\n\n KEY `comment_date` (`comment_date`),\n\n KEY `parent_comment_id` (`parent_comment_id`)\n\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\n\nCREATE TABLE `zj_labels` (\n\n `label_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'标签ID\',\n\n `label_name` varchar(20) NOT NULL COMMENT \'标签名称\',\n\n `label_alias` varchar(15) NOT NULL COMMENT \'标签别名\',\n\n `label_description` text NOT NULL COMMENT \'标签描述\',\n\n PRIMARY KEY (`label_id`),\n\n KEY `label_name` (`label_name`),\n\n KEY `label_alias` (`label_alias`)\n\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\n\nCREATE TABLE `zj_set_artitle_label` (\n\n `article_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'文章ID\',\n\n `label_id` bigint(20) NOT NULL,\n\n PRIMARY KEY (`article_id`),\n\n KEY `label_id` (`label_id`)\n\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\n\nCREATE TABLE `zj_set_artitle_sort` (\n\n `article_id` bigint(20) NOT NULL COMMENT \'文章ID\',\n\n `sort_id` bigint(20) NOT NULL COMMENT \'分类ID\',\n\n PRIMARY KEY (`article_id`,`sort_id`),\n\n KEY `sort_id` (`sort_id`)\n\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE `zj_sorts` (\n\n `sort_id` bigint(20) NOT NULL COMMENT \'分类ID\',\n\n `sort_name` varchar(50) NOT NULL COMMENT \'分类名称\',\n\n `sort_alias` varchar(15) NOT NULL COMMENT \'分类别名\',\n\n `sort_description` text NOT NULL COMMENT \'分类描述\',\n\n `parent_sort_id` bigint(20) NOT NULL COMMENT \'父分类ID\',\n\n PRIMARY KEY (`sort_id`),\n\n KEY `sort_name` (`sort_name`),\n\n KEY `sort_alias` (`sort_alias`)\n\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE `zj_user_friends` (\n\n `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'标识ID\',\n\n `user_id` bigint(20) NOT NULL COMMENT \'用户ID\',\n\n `user_friends_id` bigint(20) NOT NULL COMMENT \'好友ID\',\n\n `user_note` varchar(20) NOT NULL COMMENT \'好友备注\',\n\n `user_status` varchar(20) NOT NULL COMMENT \'好友状态\',\n\n PRIMARY KEY (`id`),\n\n KEY `user_id` (`user_id`)\n\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\n```\n\n', 'java,html', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (38, '秦志宏', 'HashMap（JDK1.8）', '', 'http://img.mrqinzh.info/java.png', '2021-04-19 00:00:00', '2021-09-17 21:06:06', '# HashMap（JDK1.8）\n\n## 成员变量\n\n```java\n//序列化编号\n	 private static final long serialVersionUID = 362498820763181265L;\n	 //默认初始容量，必须为2的幂，这里默认初始容量是16\n	 static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; \n	 //允许的最大容量，2的30次方\n	 static final int MAXIMUM_CAPACITY = 1 << 30;\n	 //默认加载因子，0.75，和容量相关的，指的是填满容量的最大比例，如果不指定就是默认的75%\n	 static final float DEFAULT_LOAD_FACTOR = 0.75f;\n	 //jdk1.8中是使用链表+数组+红黑树的方式实现的，这里指的是链表转换成树的阈值\n	 //相同数据下，红黑树所占用的空间是链表的两倍\n	 //即当桶中数量超过TREEIFY_THRESHOLD时使用树来代替链表。默认值是8\n	 static final int TREEIFY_THRESHOLD = 8;\n	 //树转换成链表的阈\n	 //当频繁的删除和插入操作时，假如一直在这个数字附近徘徊，就会频繁的在数组和红黑树之间切换\n	 //转换的数字有相差是为了减少频繁的转换带来的性能浪费\n	 //即当桶中数量小于UNTREEIFY_THRESHOLD 时用链表来代替树\n	 static final int UNTREEIFY_THRESHOLD = 6;\n	 //红黑树的最小容量\n	 static final int MIN_TREEIFY_CAPACITY = 64;\n	 //类型为Node<K,V>的数组\n	 transient Node<K,V>[] table;\n	 //保存缓存的entrySet(),用于keySet()和values()\n	 transient Set<Map.Entry<K,V>> entrySet;\n	 //table数组的长度\n	 transient int size;\n	 //更改次数，并发时用来判断是否有其他线程更改了\n	 transient int modCount;\n	 //扩容的临界值，当table的size>这个值时，会进行扩容\n	 int threshold;\n	 //实际加载因子\n	 final float loadFactor;\n```\n\n\n\n## 构造方法\n\n```java\n //创建时指定初始长度和加载因子\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n   //指定初始长度，调用了上面的构造函数，指定长度和默认加载因子\n    public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n   //创建默认的HashMap，长度和加载因子都是默认\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n    }\n    //入参一个HashMap集合\n    public HashMap(Map<? extends K, ? extends V> m) {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        putMapEntries(m, false);\n    }\n```\n\n+ ==在构造方法中，并没有对table这个成员变量进行初始化==，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算。\n\n\n\n## tableSizeFor 计算初始容量\n\n**构造方法处被调用**\n\n```java\nstatic final int tableSizeFor(int cap) { // cap 即初始容量 initialCapacity\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n\n+ 在实例化HashMap实例时，如果给定了initialCapacity，由于HashMap的capacity都是2的幂，因此==这个方法用于找到大于等于initialCapacity（初始容量）的最小的2的幂==（initialCapacity如果就是2的幂，则返回的还是这个数）。\n\n> **int n = cap - 1;**\n\n+ 这是为了防止，cap已经是2的幂。如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。\n\n```java\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n```\n\n+ 第一次右移：由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如000011xxxxxx。\n\n+ 第二次右移：这个n已经经过了`n |= n >>> 1;` 操作。假设此时n为000011xxxxxx ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如00001111xxxxxx 。\n\n+ 第三次右移：这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中会有8个连续的1。如00001111 1111xxxxxx 。\n+ ...... \n+ 注意，容量最大也就是32bit的正数，因此最后`n |= n >>> 16; `，最多也就32个1（但是这已经是负数了。在执行tableSizeFor之前，对initialCapacity做了判断，如果大于MAXIMUM_CAPACITY(2 ^ 30)，则取MAXIMUM_CAPACITY。如果等于MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作。所以这里面的移位操作之后，最大30个1，不会大于等于MAXIMUM_CAPACITY。30个1，加1之后得2 ^ 30） 。\n\n例子： initialCapacity = 10\n\n![image-20210330151224293](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210330151224293.png)\n\n```java\nthis.threshold = tableSizeFor(initialCapacity);\n```\n\n最后将`tableSizeFor`方法计算的结果赋值给`threshold`扩容临界值（当HashMap的size到达threshold这个阈值时会扩容）。\n\n\n\n## hash方法\n\n```java\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\n> hash方法解释\n\n+ 用来计算key的hash值，==为了减少hash碰撞==，获取key的hashCode后，还进行了异或运算和位运算\n+ 为什么是取>>>16,注释中有说到，计算hashcode，将较高的位扩展到较低的位，因为hash表的长度都是2的幂，而我们在之前bucket索引计算的时候可以发现，实际上大于size长度的高位，根本没有参与计算。因此，我们需要一个折衷的办法，将高位部分也能参与到计算中来。这样可以使得数据更加平均的分布在系统中。\n\n\n\n## get方法\n\n```java\n//如果取到的节点为null返回null，否则返回节点的value\n  public V get(Object key) {\n       Node<K,V> e;\n       //调用getNode方法，在下面\n       return (e = getNode(hash(key), key)) == null ? null : e.value;\n   }\n\n  //通过计算的hash值和key取出节点\n   final Node<K,V> getNode(int hash, Object key) {\n       Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n       //判断数组是否为空，并通过位运算得到table数组中的位置\n       if ((tab = table) != null && (n = tab.length) > 0 &&\n           (first = tab[(n - 1) & hash]) != null) {\n           if (first.hash == hash && // 如果hash值相同，key也相同，直接返回\n               ((k = first.key) == key || (key != null && key.equals(k))))\n               return first;\n              //如果不相同，判断是否下面还有节点，有的话就遍历查找\n           if ((e = first.next) != null) {\n           //如果是红黑树结构，按照红黑树的方式取\n               if (first instanceof TreeNode)\n               //这个方法上面有说\n                   return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            //否则就直接遍历链表，取到元素返回\n               do {\n                   if (e.hash == hash &&\n                       ((k = e.key) == key || (key != null && key.equals(k))))\n                       return e;\n               } while ((e = e.next) != null);\n           }\n       }\n       return null;\n   }\n```\n\n> **get方法总结**\n\n+ 首先计算key的hash值\n+ 通过位运算，获得hash值对应的index位置\n+ 判断当前index位置的key是否和要查找的key相同，如果相同直接返回\n+ 如果不相同，判断当前这个元素的next是不是为空，如果为空，返回null\n+ 如果不为空，判断是否是红黑树结构，如果是红黑树结构，调用红黑树的方法查找\n+ 如果是链表结构，遍历查找链表\n+ 如果找到了，返回找到的值，如果都没找到，返回null\n\n\n\n## put方法\n\n```java\npublic V put(K key, V value) {\n       return putVal(hash(key), key, value, false, true);\n   }\n//key:键，vlaue：值，onlyIfAbsent：如果key存在，是否用新值取代旧值\n//evict,在方法的最后面用到了\n   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                  boolean evict) {\n       Node<K,V>[] tab; Node<K,V> p; int n, i;\n       //如果table==null,或者tab的长度=0\n       if ((tab = table) == null || (n = tab.length) == 0)\n       //进行扩容，返回扩容后的长度，扩容的方法上面有说\n           n = (tab = resize()).length;\n          //通过位运算得到tab中index的位置，如果为空，直接设置\n       if ((p = tab[i = (n - 1) & hash]) == null)\n           tab[i] = newNode(hash, key, value, null);\n       else {\n           Node<K,V> e; K k;\n           //如果不为空，判断p的hash值和key是否相等\n           if (p.hash == hash &&\n               ((k = p.key) == key || (key != null && key.equals(k))))\n               //如果相等，把p指向e\n               e = p;\n            //如果p是红黑树结构的\n           else if (p instanceof TreeNode)\n           //直接调用红黑树的putTreeVal方法，上面有说过这个方法，如果存在的话返回的是旧的元素\n               e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n           else {\n           //如果是链表结构，遍历找到链表的最后一个元素，并记录长度\n               for (int binCount = 0; ; ++binCount) {\n               //判断是不是最后一个元素\n                   if ((e = p.next) == null) {\n                   //如果是，直接插入到这个元素后面\n                       p.next = newNode(hash, key, value, null);\n                       //判断是不是超过了链表转红黑树的那个值\n                       if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                       //如果超过了，调用TreeNode的treeifyBin方法树话链表，上面有说过\n                           treeifyBin(tab, hash);\n                       break;\n                   }\n                   //如果还不是链表的最后一个节点，且hash相等，key也相等，把获取到的p指向e\n                   if (e.hash == hash &&\n                       ((k = e.key) == key || (key != null && key.equals(k))))\n                       break;\n                   p = e;\n               }\n           }\n           if (e != null) { // existing mapping for key\n           //判断是不是要覆盖原来的值\n               V oldValue = e.value;\n               if (!onlyIfAbsent || oldValue == null)\n                   e.value = value;\n                   //afterNodeAccess是个空方法体，是为了继承HashMap的LinkedHashMap类服务的\n               afterNodeAccess(e);\n               return oldValue;\n           }\n       }\n       ++modCount;\n       //如果插入后，当前table的长度达到了需要扩容时的长度，对数组进行扩容\n       if (++size > threshold)\n           resize();\n           //一样，afterNodeInsertion也是个空方法体，是为了继承HashMap的LinkedHashMap类服务的\n       afterNodeInsertion(evict);\n       return null;\n   }\n```\n\n> put方法流程\n\n+ 首先通过计算出key的hash值\n\n+ 判断table数组是否为空，如果是空的先对数组进行初始化\n+ 如果不为空，通过位运算，获取到hash值对应的index位置\n+ 先判断index处的元素是不是为空，如果不为空，直接插入到这个位置\n+ 如果不为空，判断key是不是相同，如果是先标记出来\n+ 如果发生hash碰撞且key不相同，那么判断该节点是红黑树还是链表\n+ 如果是红黑树，调用红黑树的查找方法，判断是不是已经存在，如果存在就标记出来，不存在就插入到末尾，红黑树内部会调用方法去平衡树\n+ 如果是链表，也是一样，遍历查找，如果没有相同的key，直接插入到链表末尾，如果有的话也是标记出来\n+ 判断是否需要替换掉旧的值\n+ 再判断数组是否需要扩容，如果需要扩容再调用扩容方法\n\n\n\n## resize（扩容）方法\n\n```java\n//hashMap扩容\n    final Node<K,V>[] resize() {\n        //获得table数组、长度、实际扩容的值\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        //table数组不为空才进行后续操作\n        if (oldCap > 0) {\n            //判断当前是不是已经达到了最大值，如果是就不再扩容，返回原数组\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            //将数组扩容为原来长度的2倍，实际存放的oldThr也是一样扩容为原来的两倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        //如果使用的有参构造器，oldThr的值是创建时指定且不为0，就会使用指定的容量来完成后续的操作\n        else if (oldThr > 0) \n            newCap = oldThr;\n            //如果调用的无参构造器，要对table数组进行初始化，和触发扩容的值\n        else {    \n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        //调用有参构造器且newThr为0，重新计算赋值\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        //将计算的值指向threshold\n        threshold = newThr;\n        //创建一个新的table数组，长度为扩容后的长度，并将新的数组指向table\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        //进行数据的迁移\n        if (oldTab != null) {\n            //循环遍历旧的table\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    //如果当前位置的元素没有发生hash碰撞，即只有一个节点\n                    if (e.next == null)\n                    //直接赋值给指定位置\n                        newTab[e.hash & (newCap - 1)] = e;\n                     //如果hash相同，且这个位置的元素是红黑树结构\n                    else if (e instanceof TreeNode)\n                   //调用TreeNode的split方法，上面有详细讲过，会将红黑树分出高位和低位\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else {\n                    //如果hash碰撞，且当前位置数据是链表结构\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        //遍历循环链表，分出高位和低位\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        //和红黑树一样，低位位置不变，高位位置为当前位置+数组的旧位置\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        //返回新的数组\n        return newTab;\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'java', '原创', 0, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (47, '秦志宏', ' Spring事务', 'Spring笔记\nSpring事务的传播\n\n事务的传播行为：\n\n什么叫事务传播行为？听起来挺高端的，其实很简单。\n即然是传播，那么至少有两个东西，才可以发生传播。单体不存在传播这个行为。\n事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。\n例如：methodA事务方法调用methodB事务', 'http://img.mrqinzh.info/spring.png', '2021-06-08 16:41:53', '2021-09-17 21:08:45', '# Spring事务\n\n\n\n## Spring事务的传播\n\n+ **事务的传播行为：**\n\n什么叫**事务传播行为**？听起来挺高端的，其实很简单。 \n即然是传播，那么==至少有两个东西，才可以发生传播。单体不存在传播这个行为==。\n\n事务传播行为（propagation behavior）指的就是==当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行==。 \n例如：methodA事务方法调用methodB事务方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。\n\n+ Spring中的7个事务传播行为\n\n![image-20210408090218233](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210408090218233.png)\n\n+ 举例说明\n\n![image-20210408090335064](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210408090335064.png)\n\n> **PROPAGATION_REQUIRED**  （支持当前事务，假设当前没有事务，则新建一个事务）\n\n假如当前正要运行的事务不在另外一个事务里，那么就起一个新的事务 比方说，ServiceB.methodB的事务级别定义PROPAGATION_REQUIRED, 那么因为执行ServiceA.methodA的时候，ServiceA.methodA已经起了事务。这时调用ServiceB.methodB，ServiceB.methodB看到自己已经执行在ServiceA.methodA的事务内部。就不再起新的事务。而假如ServiceA.methodA执行的时候发现自己没有在事务中，他就会为自己分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的不论什么地方出现异常。事务都会被回滚。即使ServiceB.methodB的事务已经被提交，可是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚\n\n\n\n> **PROPAGATION_SUPPORTS** （支持当前事务，如果当前没有事务，就以非事务方式运行）\n\n假设当前在事务中。即以事务的形式执行。假设当前不在一个事务中，那么就以非事务的形式执行\n\n\n\n> **PROPAGATION_MANDATORY** （支持当前事务，假设当前没有事务，则抛出异常）\n\n必须在一个事务中执行。也就是说，他仅仅能被一个父事务调用。如果当前调用的程序没有事务执行，他就要抛出异常`throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);`\n\n\n\n> **PROPAGATION_REQUIRES_NEW** （新建事务，假设当前存在事务，则把当前事务挂起） \n\n新开启一个事务（内层事务），如果当前已经存在事务了（外层事务），会将该事务挂起，先执行新开启的事务。\n\n比方我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW。那么当运行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起。ServiceB.methodB会起一个新的事务。等待ServiceB.methodB的事务完毕以后，他才继续运行。\n他与PROPAGATION_REQUIRED 的事务差别在于事务的回滚程度了。由于ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。假设ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚。ServiceB.methodB是不会回滚的。假设ServiceB.methodB失败回滚，假设他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。\n\n\n\n> **PROPAGATION_NOT_SUPPORTED** （以非事务方式运行操作，假设当前存在事务，就把当前事务挂起）\n\n总是以非事务的方式执性，并挂起当前存在的任何事务。\n\n当前不支持事务。比方ServiceA.methodA的事务级别是PROPAGATION_REQUIRED 。而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，那么当执行到ServiceB.methodB时。ServiceA.methodA的事务挂起。而他以非事务的状态执行完，再继续ServiceA.methodA的事务。\n\n\n\n> **PROPAGATION_NEVER** （以非事务方式运行，假设当前存在事务，则抛出异常）\n\n总是以非事务的方式执性，当前存在事务，就抛异常。\n如果ServiceA.methodA的事务级别是PROPAGATION_REQUIRED。 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，那么ServiceB.methodB就要抛出异常了。\n\n\n\n> **PROPAGATION_NESTED**（如果当前存在事务，则在嵌套事务内执行，若当前不存在事务，则与PROPAGATION_REQUIRED类似）\n\n如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。\n\n\n\n+ PROPAGATION_REQUIRES_NEW 与 PROPAGATION_NESTED 的区别\n\n  PROPAGATION_REQUIRES_NEW：\n\n  + 内外层事务相互独立互不影响，外层事务回滚不会影响内层事务。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。\n  + 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。\n\n  PROPAGATION_NESTED： \n\n  + 外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。\n  + 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。\n\n  最大区别： ==PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back==。\n\n\n\n+ 注解方式开启事务\n\n```java\n// 如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)\n@Transactional(propagation=Propagation.REQUIRED)\n\n// 容器不为这个方法开启事务\n@Transactional(propagation=Propagation.NOT_SUPPORTED)\n\n// 不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务\n@Transactional(propagation=Propagation.REQUIRES_NEW)\n\n// 必须在一个已有的事务中执行,否则抛出异常\n@Transactional(propagation=Propagation.MANDATORY)\n\n// 必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)\n@Transactional(propagation=Propagation.NEVER)\n\n// 如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.\n@Transactional(propagation=Propagation.SUPPORTS)\n```\n\n\n\n\n\n\n\n\n\n', 'java,spring', '原创', 3, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (48, '秦志宏', ' MyBatis笔记', 'MyBatis笔记\n概述\n\nmybatis是什么？有什么特点？\n\n它是一款半自动的ORM持久层框架，具有较高的SQL灵活性，支持高级映射(一对一，一对多)，动态SQL，延迟加载和缓存等特性，但它的数据库无关性较低\n\n什么是ORM？\n\nObject Relation Mapping，对象关系映射。对象指的是Java对象，关系指的是数据库中的关系模型，对象关系映射，指的就是在Java对象', 'http://img.mrqinzh.info/java.png', '2021-04-20 13:10:45', '2021-09-17 21:06:06', '# MyBatis笔记\n\n## 概述\n\n+ mybatis是什么？有什么特点？\n\n它是一款**半自动的ORM持久层框架**，具有==较高的SQL灵活性，支持高级映射(一对一，一对多)，动态SQL，延迟加载和缓存==等特性，但它的数据库无关性较低\n\n+ 什么是ORM？\n\n**Object Relation Mapping，对象关系映射**。对象指的是Java对象，关系指的是数据库中的关系模型，对象关系映射，指的就是在Java对象和数据库的关系模型之间建立一种对应关系，比如用一个Java的Student类，去对应数据库中的一张student表，类中的属性和表中的列一一对应。Student类就对应student表，一个Student对象就对应student表中的一行数据\n\n+ 为什么mybatis是半自动的ORM框架？\n\n用mybatis进行开发，需要**手动编写SQL语句**。\n\nhibernate ==> 全自动的ORM框架、只需定义ORM映射关系、即可直接进行CRUD\n\nmybatis == > 手写SQL语句、灵活性较高（定制化SQL）\n\n也因为要手写SQL，当要切换数据库时，SQL语句可能就要重写，因为不同的数据库有不同的方言(Dialect)，所以mybatis的数据库无关性低。虽然mybatis需要手写SQL，但相比JDBC，它提供了输入映射和输出映射，可以很方便地进行SQL参数设置，以及结果集封装。并且还提供了关联查询和动态SQL等功能，极大地提升了开发的效率。并且它的学习成本也比hibernate低很多\n\n\n\n## 快速入门\n\n### 导入依赖\n\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.10</version>\n</dependency>\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>3.4.6</version>\n</dependency>\n```\n\n注意： 在全局配置文件中、标签要按如下顺序进行排列、因为mybatis加载配置文件的源码中是按照这个顺序进行解析的\n\n```xml\n<configuration>\n	<!-- 配置顺序如下\n     properties  \n\n     settings\n\n     typeAliases\n\n     typeHandlers\n\n     objectFactory\n\n     plugins\n\n     environments\n        environment\n            transactionManager\n            dataSource\n\n     mappers\n     -->\n</configuration>\n```\n\n使用步骤：\n\n1. 编写全局配置文件   -->  Mybatis-Config.xml\n2. 编写mapper映射文件\n3. 加载全局配置文件，生成SqlSessionFactory\n4. 通过SqlSessionFactory创建SqlSession\n5. 通过sqlsession执行数据库操作\n6. 调用session.commit()提交事务\n7. 调用session.close()关闭会话\n\n\n\n### 基于Mapper代理的示例\n\n```java\npackage com.qin.mapper;\n\nimport com.qin.pojo.Student;\n\nimport java.util.List;\n\npublic interface StudentMapper {\n\n	List<Student> findAll();\n\n	int insert(Student student);\n\n	int delete(Integer id);\n\n	List<Student> findByName(String value);\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"com.qin.mapper.StudentMapper\">\n    <select id=\"findAll\" resultType=\"com.qin.pojo.Student\">\n        SELECT * FROM student;\n    </select>\n\n    <insert id=\"insert\" parameterType=\"com.qin.pojo.Student\">\n        INSERT INTO student (name,score,age,gender) VALUES (#{name},#{score},#{age},#{gender});\n    </insert>\n\n    <delete id=\"delete\" parameterType=\"int\">\n        DELETE FROM student WHERE id = #{id};\n    </delete>\n\n    <select id=\"findByName\" parameterType=\"string\" resultType=\"com.qin.pojo.Student\">\n        SELECT * FROM student WHERE name like \'%${value}%\';\n    </select>\n</mapper>\n```\n\nmapper接口和mapper.xml之间需要遵循一定规则，才能成功的让mybatis将mapper接口和mapper.xml绑定起来\n\n+ mapper接口的全限定名，要和mapper.xml的namespace属性一致\n+ mapper接口中的方法名要和mapper.xml中的SQL标签的id一致\n+ mapper接口中的方法入参类型，要和mapper.xml中SQL语句的入参类型一致\n+ mapper接口中的方法出参类型，要和mapper.xml中SQL语句的返回值类型一致\n\n\n\n### 基于注解的示例\n\n如果实在看xml配置文件不顺眼，则可以考虑使用注解的开发方式，不过注解的开发方式，会将SQL语句写到代码文件中，后续的维护性和扩展性不是很好（如果想修改SQL语句，就得改代码，得重新打包部署，而如果用xml方式，则只需要修改xml，用新的xml取替换旧的xml即可）\n\n1、创建一个Mapper接口\n\n```java\npackage com.qin.mapper;\nimport com.qin.pojo.Student;\nimport org.apache.ibatis.annotations.Insert;\nimport org.apache.ibatis.annotations.Select;\nimport java.util.List;\n\npublic interface StudentMapper {\n\n	@Select(\"SELECT * FROM student\")\n	List<Student> findAll();\n\n	@Insert(\"INSERT INTO student (name,age,score,gender) VALUES (#{name},#{age},#{score},#{gender})\")\n	int insert(Student student);\n}\n```\n\n2、在全局配置文件中修改`<mappers>`标签，直接指定加载这个类\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <properties resource=\"properties/db.properties\"></properties>\n    <typeAliases>\n        <package name=\"com.qin.pojo\"/>\n    </typeAliases>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${db.driver}\"/>\n                <property name=\"url\" value=\"${db.url}\"/>\n                <property name=\"username\" value=\"${db.user}\"/>\n                <property name=\"password\" value=\"${db.password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <mappers>\n        <mapper class=\"com.qin.mapper.StudentMapper\"/>\n    </mappers>\n\n</configuration>\n```\n\n\n\n\n\n## 要点\n\n### 配置文件中各个标签的解释\n\n1、`<properties>`\n\n一般将数据源的信息单独放在一个properties文件中,然后用这个标签引入,在下面environment标签中，就可以用`${}`占位符快速获取数据源的信息\n\n2、`<settings>`\n\n用来开启或关闭mybatis的一些特性，比如可以用`<setting name=\"lazyLoadingEnabled\" value=\"true\"/>`来开启延迟加载，可以用`<settings name=\"cacheEnabled\" value=\"true\"/>`来开启二级缓存\n\n3、`<typeAliases>`\n\n在mapper.xml中需要使用parameterType和resultType属性来配置SQL语句的输入参数类型和输出参数类型，类必须要写上全限定名，比如一个SQL的返回值映射为Student类，则resultType属性要写com.qin.pojo.Student，这太长了，所以可以用别名来简化书写，比如\n\n```xml\n<typeAliases>\n    <typeAlias type=\"com.qin.pojo.Student\" alias=\"student\"/>\n</typeAliases>\n```\n\n+ 另外，对于基本的Java类型 -> 8大基本类型以及包装类，以及String类型，mybatis提供了默认的别名，别名为其简单类名的小写，比如原本需要写`java.lang.String`，其实可以简写为`string`\n\n4、`<typeHandlers>`\n\n用于处理Java类型和Jdbc类型之间的转换，mybatis有许多内置的TypeHandler，比如StringTypeHandler，会处理Java类型String和Jdbc类型CHAR和VARCHAR。这个标签用的不多\n\n5、`<objectFactory>`\n\nmybatis会根据`resultType`或`resultMap`的属性来将查询得到的结果封装成对应的Java类，它有一个默认的DefaultObjectFactory，用于创建对象实例，这个标签用的也不多\n\n6、`<plugins>`\n\n可以用来配置mybatis的插件，比如在开发中经常需要对查询结果进行分页，就需要用到pageHelper分页插件，这些插件就是通过这个标签进行配置的。在mybatis底层，运用了**责任链模式+动态代理去实现插件的功能**\n\n7、`<environments>`\n\n用来配置数据源\n\n8、`<mappers>`\n\n用来配置mapper.xml映射文件，这些xml文件里都是SQL语句\n\n\n\n### mapper.xml的SQL语句中的占位符`${}`和`#{}`\n\n+ #{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。\n\n+ Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。\n\n+ Mybatis在处理时 ， 是 原 值 传 入 ， 就 是 把 {}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译\n\n+ 变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’\n\n+ #{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入\n\n+ #{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外\n\n\n\n### 三种加载mapper的方式总结\n\n+ `<mapper resource=\"\" />`\n\n加载普通的xml文件，传入xml的相对路径(相对于类路径)\n\n+ `<mapper class=\"\" />`\n\n使用mapper接口的全限定名来加载，若mapper接口采用注解方式，则不需要xml;若mapper接口没有采用注解方式，则mapper接口和xml文件的名称要相同，且在同一个目录\n\n+ `<package name=\"\" />`\n\n扫描指定包下的所有mapper，若mapper接口采用注解方式，则不需要xml;若mapper接口没有采用注解方式，则mapper接口和xml文件的名称要相同，且在同一目录\n\n**注意：用后两种方式加载mapper接口和mapper.xml映射文件时，可能会报错**\n\n\n\n## 常见问题\n\n### 传统JDBC开发存在的问题\n\n+ 频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。\n+ sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。\n+ 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。\n+ 结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。\n\n\n\n### Mybatis优缺点\n\n+ **优点**\n  + 基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用\n  + 与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接\n  + 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）\n  + 提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护\n  + 能够与Spring很好的集成\n+ **缺点**\n  + SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求\n  + SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库\n\n\n\n### mybatis工作原理\n\n![image-20210412173941945](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210412173941945.png)\n\n+ 读取 全局配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。\n+ 加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。\n+ 构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。\n+ 创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。\n+ Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。\n+ MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。\n+ 输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。\n+ 输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。\n\n\n\n### Mybatis都有哪些Executor执行器？它们之间的区别是什么？\n\n**SimpleExecutor、ReuseExecutor、BatchExecutor** \n\n**SimpleExecutor**：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。（单例）\n\n**ReuseExecutor**：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map<String, Statement>内，供下一次使用。简言之，就是==重复使用Statement对象==。\n\n**BatchExecutor**：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。\n\n如何指定使用哪种执行器：在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。\n\n**作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。**\n\n\n\n### Mybatis的一级、二级缓存\n\n+ 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。\n\n+ 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置`<cache/> `；\n\n+ 对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'java,mybatis', '原创', 1, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (52, '秦志宏', ' Java 基础常见面试题', 'Java 常见面试题\nJava基础\n\nJava 中的 Math. round(-1. 5) 等于多少？\n\n等于 -1，因为在数轴上取值时，中间值（0.5）向', 'http://img.mrqinzh.info/java.png', '2021-04-30 19:24:24', '2021-09-17 21:06:06', '# Java 部分面试题\n\n\n\n## Java基础\n\n\n\n> **Java 中的 Math. round(-1. 5) 等于多少？**\n\n等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。\n\n\n\n> **String 属于基础的数据类型吗？**\n\nString 不属于基础类型，基础类型有 8 种：==byte、boolean、char、short、int、float、long、double==，而 String 属于对象。\n\n\n\n> **String str=\"i\"与 String str=new String(\"i\")一样吗？**\n\n不一样，因为内存的分配方式不一样。\n\nString str = \"i\"的方式，Java 虚拟机会将其分配到常量池中。\n\nString str = new String(\"i\") 则会被分到堆内存中。\n\n\n\n> **String** **类的常用方法都有那些？**\n\n```java\nindexOf() // 返回指定字符的索引。\n\ncharAt() // 返回指定索引处的字符。\n\nreplace() // 字符串替换。\n\ntrim() // 去除字符串两端空白。\n\nsplit() // 分割字符串，返回一个分割后的字符串数组。\n\ngetBytes() // 返回字符串的 byte 类型数组。\n\nlength() // 返回字符串长度。\n\ntoLowerCase() // 将字符串转成小写字母。\n\ntoUpperCase() // 将字符串转成大写字符。\n\nsubstring() // 截取字符串。\n\nequals() // 字符串比较。\n```\n\n\n\n> **接口和抽象类有什么区别？**\n\n实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n\n构造函数：抽象类可以有构造函数；接口不能有。\n\n实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n\n访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n\n\n> **BIO、NIO、AIO 有什么区别？**\n\nBIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\n\nNIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\n\nAIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n\n\n> **Collection 和 Collections 有什么区别？**\n\nCollection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。\n\nCollections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。\n\n\n\n> **并行和并发有什么区别？**\n\n并行：多个处理器或多核处理器同时处理多个任务。\n\n并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。\n\n并发 --> 同一时间段一起执行\n\n并行 -->同一时刻一起执行\n\n\n\n> **线程有哪些状态？**\n\nNEW 					创建\n\nRUNNABLE 		运行\n\nBLOCKED 			阻塞的（被同步锁或者IO锁阻塞）\n\nWAITING			  等待\n\nTIMED_WAITING 等待指定的时间重新被唤醒的状态\n\nTERMINATED	   终止\n\n\n\n> **创建线程池有哪几种方式？**\n\n```java\npublic static void main(String[] args) {\n\n        ExecutorService executorService1 = Executors.newSingleThreadExecutor(); // 定义单个线程的线程池\n\n        ExecutorService executorService2 = Executors.newFixedThreadPool(5); // 定义最大线程数为 5 的线程池\n\n        ExecutorService executorService3 = Executors.newCachedThreadPool(); // 定义一个可大可小的线程池\n\n    }\n```\n\n\n\n> **线程池的七大参数**\n\n```java\npublic ThreadPoolExecutor(int corePoolSize, // 核心线程数\n                              int maximumPoolSize, // 最大线程个数\n                              long keepAliveTime, // 超时等待\n                              TimeUnit unit, // 超时等待的时间单位\n                              BlockingQueue<Runnable> workQueu , // 阻塞队列（银行中的候客区）\n                              ThreadFactory threadFactory, // 线程工厂\n                              RejectedExecutionHandler handler // 拒绝策略) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?\n                null :\n                AccessController.getContext();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n\n\n> **线程池的四种拒绝策略**\n\n![image-20210328155241025](F:\\编辑工具\\Typora\\img\\image-20210328155241025.png)\n\n**默认拒绝策略**\n\n![image-20210328155435802](F:\\编辑工具\\Typora\\img\\image-20210328155435802.png)\n\n\n\n> **线程池中 submit() 和 execute() 方法有什么区别？**\n\nexecute()：只能执行 Runnable 类型的任务。\n\nsubmit()：可以执行 Runnable 和 Callable 类型的任务。\n\nCallable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。\n\n\n\n> **多线程中 synchronized 锁升级的原理是什么？**\n\n在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，==再次进入的时候会先判断 threadid 是否与其线程 id 一致==，如果一致则可以直接使用此对象，如果不一致，则**升级为轻量级锁**，通过自旋循环一定次数来获取锁，如果执行==一定次数后还没有正常获取到要使用的对象==，此时就会把锁从**升级为重量级锁**，此过程就构成了 synchronized 锁的升级。\n\n锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'java,面试', '原创', 0, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (54, '牛牛', 'Markdown学习', 'Markdown学习\n标题：\n#+空格+一级标题\n##+空格+二级标题\n…\n######+空格+六级标题\n字体\nHello，World!\nHello，World!\nHello，World!\nHello，World!\n引用（&gt;）\n\n走向人生巅峰\n\n分割线(—or***)\n\n\n图片\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E37fmLrB-161840330', 'http://img.mrqinzh.info/java.png', '2021-04-21 22:08:51', '2021-09-17 21:06:06', '\n# Markdown学习\n\n## 标题：\n\n\n\n#+空格+一级标题\n\n##+空格+二级标题\n\n......\n\n######+空格+六级标题\n\n## 字体\n\n**Hello，World!**\n\n*Hello，World!*\n\n***Hello，World!***\n\n~~Hello，World!~~\n\n## 引用（>）\n\n> 走向人生巅峰\n\n## 分割线(---or***)\n\n---\n\n***\n\n## 图片\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E37fmLrB-1618403305052)(C:\\Users\\牛牛\\Desktop\\捕获.PNG)]\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ePUou7RC-1618403305054)(图片地址，本地或者网络)]\n\n## 超链接\n\n[点击跳转](网络地址)\n\n## 列表\n\n1. a\n2. b\n\n\n\n\n\n- 啊\n- a\n- c\n\n## 表格\n\n| 名字 | 性别 | 生日     |\n| ---- | ---- | -------- |\n| 张三 | 男   | 1997.1.1 |\n\n## 代码\n\n```java\npublic \n    \n```\n\n', 'java,markdown', '原创', 1, 22, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (55, '牛牛', 'MySql基础语法', '一、sql语句要求：\n1、SQL语句可以单行或多行书写，以分号结尾；\n2、可以用空格和缩进来来增强语句的可读性；\n3、关键字不区别大小写，建议使用大写；\n二、基本操作\n查看所有数据库名称：【语法：show databases;】　\n  切换数据库：【语法：use test;】，切换到test数据库；\n  显示表：【语法：show tables;】\n  查询表：【语法：select * fro', 'http://img.mrqinzh.info/mysql.png', '2021-04-21 22:14:35', '2021-09-17 21:08:14', '一、sql语句要求：\n1、SQL语句可以单行或多行书写，以分号结尾；\n2、可以用空格和缩进来来增强语句的可读性；\n3、关键字不区别大小写，建议使用大写；\n二、基本操作\n查看所有数据库名称：【语法：show databases;】　\n  切换数据库：【语法：use test;】，切换到test数据库；\n  显示表：【语法：show tables;】\n  查询表：【语法：select * from goods;】\n创建数据库：【\n语法：\ncreate database test999;\n细粒度：如果不存在创建，存在就不创建！\ncreate database if not exists test999;\n删除数据库：【\n语法：\ndrop database test999;\n细粒度：如果存在删除，不存在就不删除！\ndrop database if exists test999;\n修改数据库编码：【语法：alter database test999 character set utf8;】\n三、数据类型\nint：整型\ndouble：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；\ndecimal：泛型型（浮点型），在表单钱方面使用该类型，因为不会出现精度缺失问题；\nchar：固定长度字符串类型；长度默认255。\nvarchar：可变长度字符串类型；（65535）\ntext：字符串类型；\nblob：字节类型；\ndate：日期类型，格式为：yyyy-MM-dd；\ntime：时间类型，格式为：hh:mm:ss\ntimestamp：时间戳类型；\n四、操作表\n创建表：【语法：】\n【语法：\nCREATE TABLE 表名(\n  列名 列类型,\n  列名 列类型,\n  ......\n);】\n修改表：\n（1）修改之添加列：给stu表添加classname列：\n【语法：\nmysql> alter table stu add(\n    -> classname varchar(100)\n-> );\n】\n（2）修改之修改列类型：修改stu表的gender列类型为CHAR(2)：\n【语法：\nmysql> alter table stu\n    -> modify gender char(2);\n】\n（3）修改之修改列名：修改stu表的gender列名为sex：\n【语法：\nmysql> alter table stu\n    -> change gender sex char(2);\n】\n（4）修改之删除列：删除stu表的classname列：\n【语法：\nmysql> alter table stu\n    -> drop classname;\n】\n（5）修改之修改表名称：修改stu表名称为student：\n【语法：\nmysql> alter table stu\n    -> rename to student;\n】\n五、 DML\n       1、插入数据\n【语法：\nINSERT INTO 表名\n(列名1,列名2, …)\nVALUES\n(值1, 值2)\n】\n【语法：\nINSERT INTO 表名 VALUES(值1,值2,…)\n】\n因为没有指定要插入的列，表示按创建表时列的顺序插入所有列的值：\n 2、修改数据\n【语法：\nUPDATE 表名 SET 列名1=值1, … 列名n=值n [WHERE 条件]\n】\n3、删除数据\n【语法：\nDELETE FROM 表名 [WHERE 条件]\n】\n【语法：\nTRUNCATE TABLE 表名\n】\n虽然TRUNCATE和DELETE都可以删除表的所有记录，但有原理不同。DELETE的效率没有TRUNCATE高！\n    TRUNCATE其实属于DDL语句，因为它是先DROP TABLE，再CREATE TABLE。而且TRUNCATE删除的记录是无法回滚的，但DELETE删除的记录是可以回滚的\n二、如何批量插入数据：\n\n\n三、使用select语句复制表：\n1、复制表结构以及数据\nCREATE TABLE 新表  \nSELECT * FROM 旧表\n2、只复制表结构\n      a、      CREATE TABLE 新表\n                 SELECT * FROM 旧表 WHERE 1=2\n                 即:让WHERE条件不成立.\n      b、:(低版本的mysql不支持，mysql4.0.25 不支持，mysql5已经支持了)\n                CREATE TABLE 新表\n                LIKE 旧表\n3.复制旧表数据到新表（两表结构一样）\n    INSERT INTO 新表\n    SELECT * FROM 旧表\n4.复制旧表数据到新表（两表结构不一样）\n     INSERT INTO 新表(字段1,字段2,…….)\n     SELECT 字段1,字段2,…… FROM 旧表', 'sql', '原创', 1, 22, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (56, '秦志宏', ' Mysql索引', 'Mysql索引\n索引介绍\n索引是什么\n\n官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。\n一般来说索引本身也很大，不可能全部存', 'http://img.mrqinzh.info/mysql.png', '2021-09-01 10:43:12', '2021-09-17 21:08:14', '# Mysql索引\n\n## 索引介绍\n\n### 索引是什么\n\n+ 官方介绍索引是帮助MySQL**高效获取数据**的**数据结构**。更通俗的说，数据库索引好比是一本书前面的目录，能**加快数据库的查询速度**。\n+ 一般来说索引本身也很大，不可能全部存储在内存中，因此**索引往往是存储在磁盘上的文件中的**（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。\n+ **我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+Tree结构组织（多路搜索树，并不一定是二叉的）的索引。**\n\n\n\n### 索引的优势和劣势\n\n优势：\n\n+ **可以提高数据检索的效率，降低数据库的IO成本**，类似于书的目录。\n+ 通过**索引列对数据进行排序**，降低数据排序的成本，降低了CPU的消耗。\n  + 被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。\n  + 如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。\n\n劣势：\n\n+ **索引会占据磁盘空间**\n+ **索引虽然会提高查询效率，但是会降低更新表的效率**。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。\n\n\n\n## 索引类型\n\n### 主键索引\n\n索引列中的值必须是唯一的，不允许有空值。\n\n### 普通索引\n\nMySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。\n\n### 唯一索引\n\n索引列中的值必须是唯一的，但是允许为空值  ==> 主键索引的区别。\n\n### 空间索引\n\nMySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。\n\n### 全文索引\n\n只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。\n\n### 前缀索引\n\n在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。\n\n### 其他（按照索引列数量分类）\n\n+ 单例索引\n+ 组合索引\n  + 复合索引是在多个字段上创建的索引。**复合索引遵守“最左前缀”原则**，**即在查询条件中使用了复合索引的第一个字段，索引才会被使用**。因此，在复合索引中索引列的顺序至关重要。\n\n#### 最左前缀原则\n\n最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配\n\n假设User表的name和city加索引就是(name,city)\n\n```sql\nselect * from user where name=xx and city=xx ; ／／可以命中索引\nselect * from user where name=xx ; // 可以命中索引\nselect * from user where city=xx ; // 无法命中索引  \nselect * from user where city=xx and name=xx ; ／／可以命中索引  \n \nexplain select * from student where name is null;//可以命中索引，使用is not null 会失效 \nexplain select * from student where name=\'zs\' and address=\'beijing\'; //name用到了索引       \n```\n\n### \n\n## 索引的数据结构\n\n### Hash表\n\nHash表\n\nkey ==> 存储索引列\n\nvalue ==> 存储行记录或者行磁盘地址\n\n查询效率高，时间复杂度为O(1)\n\n不支持范围快速查找\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'sql', '原创', 3, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (59, '秦志宏', '通过域名运行vue项目', '1、通常情况下，vue项目搭建完毕后，就可以直接通过localhost：8080访问， 但是如要使用IP 地址访问的话，将修改 config/index.js中的host：0.0.0.0，\n2、使用域名访问项目，要将域名通过解析连接服务器公网的IP地址后，才能访问。 这时使用 xxx.com:8080访问时，一般时候会出现 invalid host header 错误， 这时一', 'http://img.mrqinzh.info/vue.png', '2021-04-29 20:08:43', '2021-09-17 21:06:20', '1、通常情况下，vue项目搭建完毕后，就可以直接通过localhost：8080访问， 但是如要使用IP 地址访问的话，将修改 config/index.js中的host：0.0.0.0，\n\n2、使用域名访问项目，要将域名通过解析连接服务器公网的IP地址后，才能访问。 这时使用 xxx.com:8080访问时，一般时候会出现 invalid host header 错误， 这时一种方法是在build/webpack.dev.conf.js中的devServer中的最后添加：disableHostCheck: true。\n\n之后可以通过 xxx.com：8080 成功访问 项目主页', 'vue', '原创', 1, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (70, '秦志宏', ' Redis基础', 'Redis基础\nRedis是什么\nRedis（Remote Dictionary Server）远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库]，并提供多种语言的API。\n\n\nRedis特点\n\n\nRedis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\nRedis不仅仅支持简单的key-va', NULL, '2021-04-29 19:03:56', '2021-04-29 19:03:56', '# Redis基础\n\n## Redis是什么\n\nRedis（Remote Dictionary Server）**远程字典服务**，是一个开源的使用ANSI ==**C语言编写**==、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库]，并提供多种语言的API。\n\n![image20210429180337564.png](http://47.108.209.62:9090/files/20210429/8ec3376e-d55d-4533-9662-4bd5ef0c4339_image-20210429180337564.png)\n\n>  Redis特点\n\n+ Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n+ Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n+ Redis支持数据的备份，即master-slave模式的数据备份。\n\n\n\n> Redis优势\n\n+ 性能极高 – **Redis能读的速度是110 000次/s**,**写的速度是81 000次/s 。**\n+ 丰富的数据类型 – Redis支持二进制案例的 **Strings, Lists, Hashes, Sets 及 Ordered Sets** 数据类型操作。\n+ 原子 – **Redis的所有操作都是原子性的**，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过`MULTI`和`EXEC`指令包起来。\n\n\n\n## Redis基本命令\n\n```bash\nredis-cli	# 打开redis客户端\nredis-cli -h host -p port -a password	# 在远程 redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。\n\n# 打开后通过 ping 命令判断是否成功\n127.0.0.1:6379> ping\nPONG\n\nselect index		# 选择第index个数据库\n\nexpire key seconds		# 设置key过期时间\nttl key		# 查看当前key的过期时间\nflushdb		# 清除当前数据库的所有key\nflushall		# 清除所有数据库的key\n```\n\n### 字符串(String)\n\n```bash\n127.0.0.1:6379> set name qin	# 设置 key:value\nOK\n127.0.0.1:6379> get name	# 根据key获取value\n\"qin\"\n\n127.0.0.1:6379> getrange name 0 1	# 返回 key 中字符串值的子字符\n\"qi\"\n\n127.0.0.1:6379> getset name zhihong		# 设置新的val，并返回旧val\n\"qin\"\n\n127.0.0.1:6379> mset age 18 sex boy		# 批量设置key：value\nOK\n\n127.0.0.1:6379> mget name age sex	# 批量获取value\n1) \"zhihong\"\n2) \"18\"\n3) \"boy\"\n\n127.0.0.1:6379> setex qin 3 zhihong		# 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。\nOK\n\n127.0.0.1:6379> setnx qin 123	# 当key不存在是设置value\n(integer) 1\n\nstrlen key		# 返回key所存储字符串的长度\nmsetnx	key val [key val]		# 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。\nincr key		# 将 key 中储存的数字值增一。 i=i+1\nincrby key num		# 将 key 所储存的值加上给定的增量值（num） 。 i=i+num\ndecr key		# 将 key 中储存的数字值减一。 i=i-1\ndecrby key num		# key 所储存的值减去给定的减量值（num） 。 i=i-num\n\nappend key val		# 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。\n```\n\n\n\n### 哈希(Hash)\n\n```bash\nhdel key field ...		# 删除一个或多个哈希表字段\nhexists key field		# 查看哈希表 key 中，指定的字段是否存在。\nhget key field		# 获取存储在哈希表中指定字段的值。\nhgetall key		# 获取在哈希表中指定 key 的所有字段和值\nhincrby key field increment		# 为哈希表 key 中的指定字段的整数值加上增量 increment 。\nhkeys key		# 获取所有哈希表中的字段\nhlen key		# 获取哈希表中字段的数量\nhmget key field1 [field2]		# 获取所有给定字段的值\nhmset key field1 value1 [field2 value2 ]		# 同时将多个 field-value (域-值)对设置到哈希表 key 中。\nHSET key field value		# 将哈希表 key 中的字段 field 的值设为 value 。\nhsetnx key field value		# 只有在字段 field 不存在时，设置哈希表字段的值。\nhvals key		# 获取哈希表中所有值。\nhscan key cursor [MATCH pattern] [COUNT count]		# 迭代哈希表中的键值对。\n```\n\n\n\n### 列表(List)\n\n```bash\nblpop key1 [key2 ] timeout		# 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\nbrpop key1 [key2 ] timeout		# 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\nlindex key index		# 通过索引获取列表中的元素\nlinsert key BEFORE|AFTER pivot value		# 在列表的元素前或者后插入元素\nllen key		# 获取列表长度\nlpop key		# 移出并获取列表的第一个元素\nlpush key value1 [value2]		# 将一个或多个值插入到列表头部\nlpushx key value		# 将一个值插入到已存在的列表头部\nlrange key start stop		# 获取列表指定范围内的元素\nlrem key count value		# 移除列表元素\nlset key index value		# 通过索引设置列表元素的值\nrpop key		# 移除列表的最后一个元素，返回值为移除的元素。\nrpush key value1 [value2]		# 在列表中添加一个或多个值\nrpushx key value		# 为已存在的列表添加值\n```\n\n\n\n### 集合(Set)\n\n```bash\nsadd key member1 [member2]		# 向集合添加一个或多个成员\nscard key		# 获取集合的成员数\nsdiff key1 [key2]		# 返回第一个集合与其他集合之间的差异。\nsinter key1 [key2]		# 返回给定所有集合的交集\nsismember key member		# 判断 member 元素是否是集合 key 的成员\nsmembers key		# 返回集合中的所有成员\nsmove source destination member		# 将 member 元素从 source 集合移动到 destination 集合\nspop key		# 移除并返回集合中的一个随机元素\nsrandmember key [count]		# 返回集合中一个或多个随机数\nsrem key member1 [member2]		# 移除集合中一个或多个成员\nsunion key1 [key2]		# 返回所有给定集合的并集\nsunionstore destination key1 [key2]		# 所有给定集合的并集存储在 destination 集合中\nsscan key cursor [MATCH pattern] [COUNT count]		# 迭代集合中的元素\n```\n\n\n\n### 有序集合(sorted set)\n\n```bash\nzadd key score1 member1 [score2 member2]		# 向有序集合添加一个或多个成员，或者更新已存在成员的分数\nzcard key		# 获取有序集合的成员数\nzcount key min max		# 计算在有序集合中指定区间分数的成员数\nzincrby key increment member		# 有序集合中对指定成员的分数加上增量 increment\nzinterstore destination numkeys key [key ...]		# 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中\nzlexcount key min max	# 在有序集合中计算指定字典区间内成员数量\nzrange key start stop [WITHSCORES]		# 通过索引区间返回有序集合指定区间内的成员\nzrangebylex key min max [LIMIT offset count]		# 通过字典区间返回有序集合的成员\nzrangebyscore key min max [WITHSCORES] [LIMIT]		# 通过分数返回有序集合指定区间内的成员\nzrank key member		# 返回有序集合中指定成员的索引\nzrem key member [member ...]		# 移除有序集合中的一个或多个成员\nzremrangebylex key min max		# 移除有序集合中给定的字典区间的所有成员\nzremrangebyrank key start stop		# 移除有序集合中给定的排名区间的所有成员\nzremrangebyscore key min max		# 移除有序集合中给定的分数区间的所有成员\nzrevrange key start stop [WITHSCORES]		# 返回有序集中指定区间内的成员，通过索引，分数从高到低\nzrevrangebyscore key max min [WITHSCORES]		# 返回有序集中指定分数区间内的成员，分数从高到低排序\nzrevrank key member		# 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\nzscore key member		# 返回有序集中，成员的分数值\nzunionstore destination numkeys key [key ...]		# 计算给定的一个或多个有序集的并集，并存储在新的 key 中\nzscan key cursor [MATCH pattern] [COUNT count]		# 迭代有序集合中的元素（包括元素成员和元素分值）\n```\n\n', 'redis', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (72, '秦志宏', 'java多线程基础', 'JUC基础知识\n什么是JUC\n即： java并发编程工具包\n\n线程与进程\n\n进程\n\n进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。即一个应用程序。QQ、QQ音乐。。。\n\n线程\n\n线程是轻量级的进程，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。\njava中默认有两条线程： main线程、GC线程\njava主要靠用native本地方法调用底层C++来开启线程，', 'http://img.mrqinzh.info/java.png', '2021-04-29 19:48:48', '2021-09-17 21:06:06', '# JUC基础知识\n\n## 什么是JUC\n\n即： **java并发编程工具包**\n\n![image20210429172329196.png](http://47.108.209.62:9090/files/20210429/2ccb83cc-6ffe-40aa-9bb4-c5fcd18e557d_image-20210429172329196.png)\n\n\n## 线程与进程\n\n> 进程\n\n进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。即一个应用程序。QQ、QQ音乐。。。\n\n> 线程\n\n线程是**轻量级的进程**，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。\n\n\n\njava中默认有两条线程： main线程、GC线程\n\njava主要靠用native本地方法调用底层C++来开启线程，java无法操作硬件\n\n> java如何获取CPU核数\n\n```java\n    public static void main(String[] args) {\n        // 获取cpu的核数\n        System.out.println(Runtime.getRuntime().availableProcessors());\n    }\n```\n\n\n\n+ 并发\n  + CPU一核，模拟出来多条线程，天下武功，唯快不破，快速交替制造出的假象！\n  + 同一时刻只有一条线程执行任务\n+ 并行\n  + CPU多核，多个线程可以同时执行；线程池\n  + 同一时刻有多条线程执行任务，真正的并行\n\n\n\n### 线程的状态\n\n6种\n\n```java\npublic enum State {\n        /**\n         * 创建\n         */\n        NEW,\n\n        /**\n         * 运行\n         */\n        RUNNABLE,\n\n        /**\n         * 阻塞\n         */\n        BLOCKED,\n\n        /**\n         * 等待\n         */\n        WAITING,\n\n        /**\n         * 超时等待\n         */\n        TIMED_WAITING,\n\n        /**\n         * 终止\n         */\n        TERMINATED;\n    }\n```\n\n\n\n> wait和sleep有什么区别\n\n1、来自不同的类。wait == > Object		sleep == > Thread\n\n2、关于锁的释放。wait会释放锁		sleep不会（抱着锁睡觉）\n\n3、使用范围不同。wait必须在同步代码块		sleep可以在任何地方\n\n4、异常。wait不需要捕获异常		sleep需要捕获异常\n\n\n', 'java', '原创', 1, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (73, '秦志宏', ' SpringBoot 自动装配原理', 'SpringBoot 自动装配\n@SpringBootApplication\n\n主启动类\n\n@SpringBootApplication\npublic class Springboot01Application {\n\n    public static void main(String[] args) {\n        //将Spring Boot应用启动\n        SpringAppli', 'http://img.mrqinzh.info/springboot.png', '2021-05-07 20:57:09', '2021-09-17 21:08:52', '# SpringBoot 自动装配\n\n## @SpringBootApplication\n\n> SpringBoot启动类\n\n```java\n@SpringBootApplication\npublic class Springboot01Application {\n\n    public static void main(String[] args) {\n        //将Spring Boot应用启动\n        SpringApplication.run(Springboot01Application.class, args);//反射机制\n    }\n\n}\n```\n\n> @SpringBootApplication\n\n这个注解，标志这是SpringBoot的主启动类\n\n点进这个注解\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    \n}\n```\n\n+ @SpringBootConfiguration： 表示这是一个SpringBoot的配置类\n+ @EnableAutoConfiguration： 自动装配的主要注解\n+ @ComponentScan： 扫描启动类同级的包目录，将扫描到的组件交给Spring容器管理\n\n\n\n## @SpringBootConfiguration\n\n> @SpringBootConfiguration\n\n其中又发现两个注解\n\n+ @Configuration： 表示这是一个配置类\n+ @Component： 这是一个Spring的组件\n\n> @ComponentScan\n\n`@ComponentScan`主要就是定义扫描的路径从中找出标识了需要装配的类自动装配到spring的bean容器中。\n\n\n\n## @EnableAutoConfiguration\n\n> @EnableAutoConfiguration	（重要） SpringBoot自动装配的核心注解\n\n点进观察\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n    Class<?>[] exclude() default {};\n\n    String[] excludeName() default {};\n}\n```\n\nSpring源码中很多的`Enable xxxx`开头的注解： 借助@Import来注册满足一些条件的Bean，并加载到容器中\n\n\n\n### @AutoConfigurationPackage\n\n> @AutoConfigurationPackage	自动配置包\n\n`@AutoConfigurationPackage`注解就是将主启动类（`@SpringBootApplication`）标注的所有包及子包里面的所有组件扫描到Spring容器当中。\n\n\n\n### @Import({AutoConfigurationImportSelector.class})\n\n> @Import({AutoConfigurationImportSelector.class})\n\n将`AutoConfigurationImportSelector`这个类导入到spring容器中，AutoConfigurationImportSelector可以帮助springboot应用将**所有符合条件的**@Configuration配置都加载到当前SpringBoot创建并使用的spring容器(ApplicationContext)中。\n\n`AutoConfigurationImportSelector`源码中： 通过`selectImports`方法告诉SpringBoot需要导入的组件\n\n```java\n@Override\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n    if (!isEnabled(annotationMetadata)) {\n        return NO_IMPORTS;\n    }\n    //获得自动配置实体\n    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);\n    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n}\n\n```\n\n\n\n> **getCandidateConfigurations**方法\n\nSpringBoot 在启动的时候从类路径下的 `META-INF/spring.factories`中获取EnableAutoConfiguration指定的值(也就是启动器)，将这些作为自动配置类导入到容器当中，自动配置类就生效，帮我们进行自动配置。\n\n```java\n//获取候选配置	\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n    。\n        List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n                                                                             getBeanClassLoader());\n    Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \"\n                    + \"are using a custom packaging, make sure that file is correct.\");\n    return configurations;\n}\n```\n\n查看SpringBoot的autoconfigure依赖包中的META-INF/spring.factories配置文件\n\n```properties\n----\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdmin- JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.PropertyPlaceholderAuto- Configuration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAuto-Configuration,\\\norg.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationProperties-AutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceException-TranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.Cassandra-DataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.Cassandra-RepositoriesAutoConfiguration,\\\n----\n```\n\n`@EnableAutoConfiguration`自动配置的原理就是：从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中的`org.springframework.boot.autoconfigure.EnableAutoConfiguration`对应的配置项通过反射实例化为对应的标注了@Configuration的javaConfig形式的IOC容器配置类，然后汇总为一整个并加载到IOC容器。\n\n\n\n![20210425150236978.png](http://47.108.209.62:9090/files/20210427/07590c7f-433e-44c9-a713-4d38720c2e9b_20210425150236978.png)\n\n\n\n\n## Spring源码中的一些常见注解\n\n+ @ConditionalOnClass ： classpath中存在该类时起效\n+ @ConditionalOnMissingClass ： classpath中不存在该类时起效\n+ @ConditionalOnBean ： 容器中存在该类型Bean时起效\n+ @ConditionalOnMissingBean ： 容器中不存在该类型Bean时起效\n+ @ConditionalOnSingleCandidate ： 容器中该类型Bean只有一个或@Primary的只有一个时起效\n+ @ConditionalOnExpression ： SpEL表达式结果为true时\n+ @ConditionalOnProperty ： 参数设置或者值一致时起效\n+ @ConditionalOnResource ： 指定的文件存在时起效\n+ @ConditionalOnJndi ： 指定的JNDI存在时起效\n+ @ConditionalOnJava ： 指定的Java版本存在时起效\n+ @ConditionalOnWebApplication ： Web应用环境下起效\n+ @ConditionalOnNotWebApplication ： 非Web应用环境下起效\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'springboot,面试', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (77, '秦志宏', '前后端分离集成websocket', 'SpringBoot与Vue集成websocket\nwebsocket是什么\n\n什么是websocket\n\nWebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。\n能够使服务器主动的向浏览器发送最新消息\n\n作用\n\n即时通讯，替代轮询\n网站上的即时通讯是很常见的，比如网页的QQ，聊天系统等。按', 'http://img.mrqinzh.info/springboot.png', '2021-05-07 22:55:05', '2021-09-17 21:08:52', '# SpringBoot与Vue集成websocket\n\n## websocket是什么\n\n> websocket解释\n\nWebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。\n\n能够使服务器主动的向浏览器发送最新消息\n\n> 作用\n\n**即时通讯，替代轮询**\n\n网站上的即时通讯是很常见的，比如网页的QQ，聊天系统等。按照以往的技术能力通常是采用**轮询、Comet**技术解决。\n\n+ **HTTP协议是非持久化的，单向的网络协议**，在建立连接后只允许浏览器向服务器发出请求后，服务器才能返回相应的数据。当需要即时通讯时，通过轮询在特定的时间间隔（如1秒），由浏览器向服务器发送Request请求，然后将最新的数据返回给浏览器。这样的方法最明显的缺点就是需要不断的发送请求，而且通常HTTP request的Header是非常长的，为了传输一个很小的数据 需要付出巨大的代价，是很不合算的，占用了很多的宽带。**会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在相同的头部信息上**\n\n\n\n然而WebSocket的出现可以弥补这一缺点。在WebSocket中，只需要**服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送**。\n\n\n\n> WebSocket与HTTP的关系\n\n+ 相同点\n  + 都是一样基于TCP的，都是可靠性传输协议。\n  + 都是应用层协议。\n+ 不同点\n  +  WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。\n  + WebSocket是需要握手进行建立连接的。\n+ 联系\n  + Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。\n\n\n\n**Socket是传输控制层协议，WebSocket是应用层协议。**\n\n\n\n## 后端SpringBoot集成\n\n1、先引入maven依赖\n\n```xml\n<!--  websocket  -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-websocket</artifactId>\n</dependency>\n```\n\n2、创建WebSocketConfig配置类\n\n```java\npackage com.qin.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n\n/**\n * 开启WebSocket支持\n */\n@Configuration  \npublic class WebSocketConfig {  \n	\n    @Bean  \n    public ServerEndpointExporter serverEndpointExporter() {  \n        return new ServerEndpointExporter();  \n    }\n  \n} \n```\n\n3、编写WebSocket服务类\n\n```java\npackage com.qin.util;\n\nimport org.springframework.stereotype.Component;\n \nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.concurrent.CopyOnWriteArraySet;\n \n@ServerEndpoint(value = \"/qin/websocket\")\n@Component\npublic class WebSocketServer {\n    /**\n     * 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。\n     */\n    private static int onlineCount = 0;\n    /**\n     * concurrent包的线程安全Set，用来存放每个客户端对应的WebSocketServer对象，利用了Set的不重复性。\n     */\n    private static CopyOnWriteArraySet<WebSocketServer> webSocketSet = new CopyOnWriteArraySet<>();\n    /**\n     * 与某个客户端的连接会话，需要通过它来给客户端发送数据\n     */\n    private Session session;\n \n    /**\n     * 连接建立成功时调用的方法\n     * @param session   获取连接客户端的session\n     */\n    @OnOpen\n    public void onOpen(Session session) {\n        this.session = session;\n        //加入set中\n        webSocketSet.add(this);\n        //添加在线人数\n        addOnlineCount();\n        System.out.println(\"新连接，当前在线人数为：\" + getOnlineCount());\n    }\n \n    /**\n     * 连接关闭时调用的方法\n     */\n    @OnClose\n    public void onClose() {\n        //从set中删除\n        webSocketSet.remove(this);\n        //在线数减1\n        subOnlineCount();\n        System.out.println(\"有连接关闭，当前在线人数为：\" + getOnlineCount());\n    }\n \n    /**\n     * 收到客户端消息后调用此方法\n     * @param message   消息内容\n     * @param session   客户端的session\n     */\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        System.out.println(\"客户端发送的消息：\" + message);\n    }\n \n    /**\n     * 暴露给外部的群发\n     * @param message   需要发送的消息\n     */\n    public static void sendInfo(String message){\n        sendAll(message);\n    }\n \n    /**\n     * 群发消息内容\n     * @param message   需要发送的消息\n     */\n    private static void sendAll(String message) {\n        Arrays.asList(webSocketSet.toArray()).forEach(item -> {\n            WebSocketServer customWebSocket = (WebSocketServer) item;\n            //群发\n            try {\n                customWebSocket.sendMessage(message);   // 发送消息\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n \n    /**\n     * 发生错误时调用\n     */\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n \n    /**\n     * 减少在线人数\n     */\n    private void subOnlineCount() {\n        WebSocketServer.onlineCount--;\n    }\n \n    /**\n     * 添加在线人数\n     */\n    private void addOnlineCount() {\n        WebSocketServer.onlineCount++;\n    }\n \n    /**\n     * 当前在线人数\n     */\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n \n    /**\n     * 发送信息\n     * @param message   消息内容\n     */\n    public void sendMessage(String message) throws IOException {\n        //获取session远程基本连接发送文本消息\n        this.session.getBasicRemote().sendText(message);\n        //this.session.getAsyncRemote().sendText(message);\n    }\n}\n```\n\n\n\n## 前端Vue代码\n\n1、在需要实现界面的methods中添加以下方法\n\n```js\n// websocket方法\ninitWebSocket: function () {\n    this.websock = new WebSocket(\"ws://localhost:9090/qin/websocket\");\n    this.websock.onopen = this.websocketonopen;\n    this.websock.onerror = this.websocketonerror;\n    this.websock.onmessage = this.websocketonmessage;\n    this.websock.onclose = this.websocketclose;\n},\nwebsocketonopen: function () {\n    console.log(\"WebSocket连接成功\");\n},\nwebsocketonerror: function (e) {\n    console.log(\"WebSocket连接发生错误\");\n},\n// 接受数据\nwebsocketonmessage: function (e) {\n    console.log(e);\n},\n// 数据发送\nwebsocketsend(Data) {\n     this.websock.send(Data)\n},\nwebsocketclose: function (e) {\n     console.log(\"connection closed (\" + e + \")\");\n}\n```\n\n2、创建和关闭的方法\n\n```js\ncreated() {\n    this.initWebSocket()\n},\ndestroyed() {\n    this.websocketclose();\n},\n```\n\n\n\n## 测试\n\n用redis监听key过期方法来测试\n\n1、首先创建KeyExpiredListener类\n\n```java\npackage com.qin.util;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.data.redis.connection.Message;\nimport org.springframework.data.redis.listener.KeyExpirationEventMessageListener;\nimport org.springframework.data.redis.listener.RedisMessageListenerContainer;\nimport org.springframework.stereotype.Component;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Component\npublic class KeyExpiredListener extends KeyExpirationEventMessageListener {\n \n    public KeyExpiredListener(RedisMessageListenerContainer listenerContainer) {\n        super(listenerContainer);\n    }\n \n    @Override\n    public void onMessage(Message message, byte[] pattern) {\n        String expireKey = message.toString();\n        System.out.println(\"过期key:\" + expireKey);\n        Map<String,Object> map = new HashMap<>();\n        map.put(\"key\",expireKey);\n        try {\n            WebSocketServer.sendInfo(new ObjectMapper().writeValueAsString(map));\n\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n2、在RedisConfig类中配置\n\n```java\n@Bean\npublic RedisMessageListenerContainer redisMessageListenerContainer(){\n    RedisMessageListenerContainer redisMessageListenerContainer = new RedisMessageListenerContainer();\n    redisMessageListenerContainer.setConnectionFactory(redisConnectionFactory);\n    return redisMessageListenerContainer;\n}\n```\n\n\n\n3、通过设置redis定时key\n\n```bash\n127.0.0.1:6379> setex name 5 qin\nOK\n127.0.0.1:6379> \n```\n\n\n\n4、运行结果\n\nSpringBoot\n![image.png](http://47.108.209.62:9090/files/20210507/6a0aeb72-9507-45ae-b9f3-9e35575efaca_image.png)\n\n\nVue\n![image.png](http://47.108.209.62:9090/files/20210507/7ca840fe-6e06-4865-a361-3813fa8fd856_image.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'springboot', '原创', 7, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (78, '秦志宏', 'vue实现主页面', '基于Vue的博客主页\n图片预览：\n\n代码：\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-col :xs=\"24\" :sm=\"24\" :md=\"18\" :lg=\"', 'http://img.mrqinzh.info/vue.png', '2021-05-10 10:53:37', '2021-09-17 21:06:20', '## 基于Vue的博客主页\n\n图片预览：\n![image.png](http://47.108.209.62:9090/files/20210510/73e0610a-ad13-4d4e-b8fe-f194f15d5115_image.png)\n\n代码： \n```html\n<template>\n  <div>\n    <el-col :xs=\"24\" :sm=\"24\" :md=\"18\" :lg=\"18\" :xl=\"18\">\n      <!-- 头部滚动栏 -->\n      <div style=\"box-shadow: 0 2px 4px rgba(0, 0, 0, .12), 0 0 6px rgba(0, 0, 0, .04);background-image: linear-gradient(-225deg, #FFFEFF 0%, #D7FFFE 100%);\">\n        <i class=\"layui-icon layui-icon-speaker\" style=\"margin-left: 10px;font-size: 30px;color: #c26565\"></i>\n        <div class=\"roll\">\n          <ul>\n            <li v-for=\"(item, index) in ulList\" \n            :key=\"item.id\" \n            :class=\"!index && play ? \'toUp\' : \'\'\">\n              <span>{{item.msg}}</span>\n            </li>\n          </ul>\n        </div>\n      </div>\n    </el-col>\n\n    <!-- 抽屉 -->\n    <el-drawer\n      title=\"添加好友\"\n      :visible.sync=\"drawer\"\n      size=\"20%\"\n      :direction=\"direction\">\n      <div class=\"left_drawer\">\n        <div>\n          <p>感谢你的访问</p>\n          <p>如果可以，欢迎你的加入</p>\n          <p>\n            <i class=\"el-icon-caret-bottom\"></i>\n            &nbsp;\n            <i class=\"el-icon-caret-bottom\"></i>\n            &nbsp;\n            <i class=\"el-icon-caret-bottom\"></i>\n          </p>\n          <el-divider></el-divider>\n          <p style=\"margin-top: 30px\">\n            微信 <br>\n            <img src=\"../../static/img/vx.jpg\" style=\"width: 150px; height: 150px\">\n          </p>\n          <p style=\"margin-top: 30px\">\n            QQ <br>\n            <img src=\"../../static/img/qq.jpg\" style=\"width: 150px; height: 150px\">\n          </p>\n        </div>\n        <div style=\"margin-top: 20px\">\n          <span>网站运行时长：{{ count_time }}</span>\n        </div>\n      </div>\n    </el-drawer>\n\n    <div class=\"layui-row\">\n      <!-- 左 -->\n      <el-col :xs=\"24\" :sm=\"24\" :md=\"6\" :lg=\"6\" :xl=\"6\">\n        <div class=\"layui-anim layui-anim-upbit\">\n          <!-- 左边个人信息简介 -->\n          <div style=\"margin: 30px 15px 0 0\" >\n            <div class=\"user-card\">\n              <!-- 头像 -->\n              <div style=\"padding: 20px;\">\n                <el-upload\n                title=\"点击更换头像\"\n                class=\"avatar-uploader\"\n                action=\"#\"\n                :show-file-list=\"false\"\n                :http-request=\"uploadSectionFile\">\n                  <img v-if=\"imageUrl\" :src=\"imageUrl\" class=\"avatar\">\n                  <i v-else class=\"el-icon-plus avatar-uploader-icon\"></i>\n                </el-upload>\n              </div>\n              <!-- 姓名、座右铭 -->\n              <div style=\"font-family: STKaiti\">\n                <span style=\"font-size: 20px;\">{{user.name}}</span><br>\n                <span style=\"font-size: 15px;line-height: 2em\">{{user.motto}}</span>\n              </div>\n              <div style=\"margin-top: 10px\">\n                <el-button @click=\"drawer = true\" type=\"primary\" round style=\"margin-left: 16px;\" class=\"hidden-xs-only\">\n                  点击发现新世界\n                </el-button>\n              </div>\n              <hr>\n              <div>\n                <span style=\"letter-spacing: 1em;color: #67C23A\">\n                  <el-tooltip class=\"item\" effect=\"dark\" :content=\"user.vx\" placement=\"bottom-start\">\n                    <i class=\"layui-icon layui-icon-login-wechat\" style=\"font-size: 35px\"></i>\n                  </el-tooltip>\n                  <el-tooltip class=\"item\" effect=\"dark\" :content=\"user.qq\" placement=\"bottom-start\">\n                    <i class=\"layui-icon layui-icon-login-qq\" style=\"font-size: 35px\"></i>\n                  </el-tooltip>\n                  <el-tooltip class=\"item\" effect=\"dark\" :content=\"user.tel\" placement=\"bottom-start\">\n                    <i class=\"layui-icon layui-icon-cellphone\" style=\"font-size: 35px\"></i>\n                  </el-tooltip>\n                </span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </el-col>\n\n      <!-- 中间 -->\n      <el-col :xs=\"24\" :sm=\"24\" :md=\"12\" :lg=\"12\" :xl=\"12\" v-loading=\"loading\">\n        <div class=\"layui-anim layui-anim-upbit\">       \n          <div style=\"min-height: 600px\">\n            <div class=\"mystory\" v-for=\"(item, index) in articles\" :key=\"index\">\n              <div class=\"title\">\n                <blockquote style=\"border-left: 4px solid #409EFF\">\n                  <h1 style=\"padding-left: 10px\">\n                    <a class=\"boxchilde\" @click=\"showBlog(item.article_id)\">\n                      <span>{{item.article_title}}</span>\n                    </a>\n                  </h1>\n                </blockquote>\n              </div>\n              <div class=\"info\">\n                <span><i class=\"el-icon-date\"></i>&nbsp;&nbsp;<a>{{item.article_time}}</a></span>\n                &nbsp;&nbsp;&nbsp;&nbsp;<span><i class=\"el-icon-user\"></i>&nbsp;&nbsp;<a>{{item.article_author}}</a></span>\n                &nbsp;&nbsp;&nbsp;&nbsp;<span><i class=\"el-icon-s-promotion\"></i>&nbsp;&nbsp;<a>我的文章</a></span>\n              </div>\n              <div class=\"content\">\n                &nbsp;&nbsp;&nbsp;&nbsp;<span>{{item.article_body}}。。。</span>\n              </div>\n              <hr>\n              <div class=\"foot\">\n                <span v-for=\"(tag, index) in item.article_tag.split(\',\')\" :key=\"index\">\n                  <i class=\"layui-icon layui-icon-note\"></i>&nbsp;&nbsp;<a>{{tag}}</a>&nbsp;&nbsp;\n                </span>\n              </div>\n            </div>\n          </div>\n          <div style=\"text-align: center;margin-top: 20px\">\n            <!-- 分页 -->\n            <el-pagination\n              v-if=\"totalCount > 10\"\n              background\n              layout=\"prev, pager, next\"\n              :page-size=\"pageSize\"\n              :total=\"totalCount\"\n              :current-page=\"currentPage\"\n              @current-change=\"changePageNum\">\n            </el-pagination>\n          </div>\n        </div>\n      </el-col>\n\n      <!-- 右 -->\n      <el-col :xs=\"24\" :sm=\"24\" :md=\"6\" :lg=\"6\" :xl=\"6\">\n        <div class=\"layui-anim layui-anim-upbit\" style=\"margin: 15px\">\n          <div>\n            <el-card class=\"right-card\" style=\"background-image: linear-gradient(to top, #e6e9f0 0%, #eef1f5 100%);\">\n              <div style=\"font-size: 15px;line-height: 2em\">\n                <span style=\"text-align: center;font-family: KaiTi\"><h1>欢迎访问我的博客 !&nbsp;!&nbsp;!</h1></span>\n                <div style=\"margin-top: 10px\">\n                  <span><i class=\"el-icon-warning-outline\"></i>&nbsp;&nbsp;入站需知：</span><br>\n                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span><i class=\"el-icon-caret-right\"></i>&nbsp;&nbsp;网站是基于SpringBoot + Vue 的一个前后端分离项目</span><br>\n                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span><i class=\"el-icon-caret-right\"></i>&nbsp;&nbsp;若对源码有兴趣，可以访问&nbsp;&nbsp;<i class=\"el-icon-d-arrow-right\"></i>&nbsp;&nbsp;<a href=\"https://gitee.com/mrqinzh/web\" target=\"_blank\" style=\"color: #409EFF\">代码</a></span><br>\n                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span><i class=\"el-icon-caret-right\"></i>&nbsp;&nbsp;项目持续开发中，敬请期待！！！</span><br>\n                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span><i class=\"el-icon-caret-right\"></i>&nbsp;&nbsp;欢迎大家为我提出BUG，或者加入我，一起开发&nbsp;&nbsp;<i class=\"el-icon-s-flag\"></i></span><br>\n                  <span style=\"float: right;\">--- qzh</span>\n                </div>\n              </div>\n            </el-card>\n            <el-carousel height=\"250px\" style=\"margin: 30px 0\">\n              <el-carousel-item v-for=\"(item, index) in carousel_imgs\" :key=\"index\">\n                <img :src=\"item.img_src\" :fit=\"index\" style=\"width: 100%; height: 100%\">\n              </el-carousel-item>\n            </el-carousel>\n          </div>\n          <LinkCard></LinkCard> \n        </div>\n      </el-col>\n    </div>\n  \n    <!-- 分割线 -->\n    <el-divider content-position=\"right\"><i class=\"el-icon-wind-power\"></i></el-divider>\n\n  </div>\n</template>\n\n<script>\nimport LinkCard from \'./partial/LinkCard\';\nimport {logOrNot } from \'../utils/utils\'\nimport { postRequest, uploadFileRequest } from \'../utils/api\'\n  export default {\n    components: {\n      \'LinkCard\': LinkCard,\n    },\n    data() {\n      return {\n        loading: true,\n        // 公告\n        play: false,\n        ulList: [\n          { msg: \'只要学不死，就往死里学。当你牛逼到一定程度时，你就有了话语权。累了看看父母，倦了想想未来。\' },\n          { msg: \'不同的人，即使站在同一个地方，透过各自的人生，看到的风景也有所不同。\' },\n          { msg: \'曾经我以为：孤独是世界上只剩一个人。现在我认为：孤独是自己竟能成为一个世界。\' },\n        ],\n        // 轮播图片\n        carousel_imgs: [\n          { img_src: \'../../static/img/genshen.png\', },\n          { img_src: \'../../static/img/genshen2.png\', }\n        ],\n        // 用户信息\n        user: {\n          name: \'秦志宏\',\n          vx: \'qzh09010\',\n          qq: \'1552589784\',\n          tel: \'157-3056-7860\',\n          motto: \'别人拥有的，不必羡慕；只要努力，时间都会给你\', // 座右铭\n        },\n        // 分页\n        totalCount: 0,\n        currentPage: 1,\n        pageSize: 10,\n        // 抽屉\n        drawer: false,\n        direction: \'ltr\',\n\n        // 中间博客文章部分\n        articles: [],\n        // 开发天数\n        start_time: \'2021-4-10 14:10:00\',\n        count_time: \'00:00:00\',\n        start_use_time: \'2021-04-17 16:30:00\',\n\n        imageUrl: \'../../static/img/touxiang.jpg\', // 用户头像url 设置了默认头像\n\n        log: false, // 判断是否登录\n      }\n    },\n    methods: {\n      // 加载博客\n      loadBlogs(currentPage, pageSize) {\n        postRequest(\'/article/orderArticle\', {\n          currentPage: currentPage,\n          pageSize: pageSize,\n        }).then(resp => {\n          // console.log(resp);\n          this.articles = resp.data.list;\n          this.totalCount = resp.data.count; //获取数据行数\n          this.loading = false;\n        });\n      },\n      // 展示博客\n      showBlog(id) {\n        let routeData = this.$router.resolve({path: \'/blog\', query: {article_id: id}})\n        window.open(routeData.href, \'_blank\');\n      },\n      // 页码变更\n      changePageNum(val) {\n        this.currentPage = val;\n        this.loadBlogs(this.currentPage, this.pageSize);\n      },\n      // 头部公告滚动\n      startPlay() {\n        let that = this\n        that.play = true //开始播放\n        setTimeout(() => {\n          that.ulList.push(that.ulList[0]) //将第一条数据塞到最后一个\n          that.ulList.shift() //删除第一条数据\n          that.play = false //暂停播放\n        }, 500)\n      },\n      // 计算网页运行时长\n      countTime (startTime) {\n        if (!startTime) return\n        let start_time = new Date(startTime)\n        let _this = this\n        this.timer = setInterval(() => {\n          let millisecond = new Date() - start_time\n          let d = Math.floor(millisecond / (24 * 60 * 60 * 1000))\n\n          let h = Math.floor(millisecond % (24 * 60 * 60 * 1000) / (60 * 60 * 1000))\n          h = h < 10 ? \'0\' + h : h\n          let min = Math.floor(millisecond % (60 * 60 * 1000) / (60 * 1000))\n          min = min < 10 ? \'0\' + min : min\n          let sec = Math.floor(millisecond % (60 * 60 * 1000) % (60 * 1000) / 1000)\n          sec = sec < 10 ? \'0\' + sec : sec\n          _this.count_time = d + \'天\' + h + \'小时\' + min + \'分钟\' + sec + \'秒\'\n        }, 1000)\n      },\n      // 上传头像方法\n      uploadSectionFile(params) {\n        if(!logOrNot()){\n          this.$message.info(\'要不咋还是考虑上个号了，再来操作吧。\');\n          return;\n        }\n        const file = params.file,\n        fileType = file.type,\n        isImage = fileType.indexOf(\"image\") != -1,\n        isLt2M = file.size / 1024 / 1024 < 2;\n        // 这里常规检验，看项目需求而定\n        if (!isImage) {\n          this.$message.error(\"只能上传图片格式png、jpg、gif!\");\n          return;\n        };\n        if (!isLt2M) {\n          this.$message.error(\'上传头像图片大小不能超过 2MB!\');\n          return;\n        };\n        var formdata = new FormData();\n        formdata.append(\'file\', file);\n        uploadFileRequest(\'/file/headImg\', formdata).then(resp => {\n          // console.log(resp)\n          if(resp.data.message !== \"success\"){\n            this.$message.info(resp.data.message);\n          } else {\n            this.imageUrl = resp.data.body;\n            localStorage.setItem(\"head_img_url\",resp.data.body)\n          }\n        },\n        err => {\n          this.$message.error(\'服务器好像出了点小问题\');\n          this.imageUrl = \'../../static/img/touxiang.jpg\';\n        });\n      },\n\n    },\n\n\n    mounted() {\n      // console.log(localStorage.getItem(\"head_img_url\"));\n      if(localStorage.getItem(\"head_img_url\") != null){\n        this.imageUrl = localStorage.getItem(\"head_img_url\");\n      } else {\n        this.imageUrl = \'../../static/img/touxiang.jpg\';\n      }\n      \n      setInterval(this.startPlay, 4000);\n      // console.log(logOrNot())\n      this.loadBlogs(this.currentPage, this.pageSize);\n      this.log = logOrNot();\n\n    },\n    created () {\n      // 调用时机根据需求\n      this.countTime(this.start_time)\n    }\n    \n  }\n</script>\n\n<style>\n  /* 中间博客卡片 */\n  .mystory {\n    margin: 30px auto;\n    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);\n    transition: all 0.3s ease-in;\n  }\n  .mystory:hover {\n    transform: translate(0, -5px);\n    box-shadow: 0 2px 12px 0 rgba(189, 102, 197, 0.6);\n  }\n  .title {\n    padding: 15px 0 0 20px;\n  }\n  .info {\n    margin: 20px 0 0 20px;\n  }\n  .content {\n    margin: 15px;\n    font-size: 17px;\n    line-height: 2em;\n    min-height: 130px;\n  }\n  .foot {\n    padding: 0 0 10px 20px;\n    font-size: 17px;\n  }\n  .mystory a:hover {\n    cursor: pointer;\n    color: #318fb5;\n    text-decoration: underline;\n  }\n  .user-card {\n    width: 100%;\n    min-height: 320px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, .12), 0 0 6px rgba(0, 0, 0, .04);\n    background-color: #F2F6FC;\n    text-align: center\n\n  }\n\n  /* 左侧抽屉 */\n  .left_drawer {\n    text-align: center;\n    margin: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, .12), 0 0 6px rgba(0, 0, 0, .04);\n    font-size: 18px;\n    background-image: linear-gradient(-225deg, #FFFEFF 0%, #D7FFFE 100%);\n  }\n\n  /* 滚动栏 */\n  .roll {\n    display: inline-block;\n    width: 90%;\n    height: 21px;\n    position: relative;\n    overflow: hidden;\n    margin-left: 10px;\n  }\n  .roll ul {\n    list-style: none;\n    overflow: hidden;\n    height: 20px;\n    padding: 0;\n    margin: 0;\n  }\n  .roll li {\n    text-align: left;\n    height: 20px;\n    line-height: 20px;\n  }\n  .toUp {\n    margin-top: -20px;\n    transition: all 1s;\n  }\n\n  /* 头像上传的css */\n  .avatar-uploader .el-upload {\n    border: 1px dashed #d9d9d9;\n    border-radius: 50px;\n    cursor: pointer;\n    position: relative;\n    overflow: hidden;\n  }\n  .avatar-uploader .el-upload:hover {\n    border-color: #409EFF;\n  }\n  .avatar-uploader-icon {\n    font-size: 28px;\n    color: #8c939d;\n    width: 100px;\n    height: 100px;\n    line-height: 100px;\n    text-align: center;\n  }\n  .avatar {\n    width: 100px;\n    height: 100px;\n    display: block;\n  }\n\n  /* 中间文章内容的title动画 */\n  .boxchilde{\n    display: inline-block;\n    transition: all 0.4s ease-in;\n    overflow: hidden;\n  }\n  .boxchilde:hover{\n    cursor: pointer;\n    transform: translate(20px,0);\n  }\n\n</style>\n```\n', 'vue', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (79, '秦志宏', 'Vue+ElementUI实现表格分页', 'Vue + ElementUI实现表格及分页\n介绍\n主要实现的功能有： 数据添加、删除、以及多行删除。\n因为没有连接后台，所有不能保证数据的持久性。\n图片预览：\n\n实现代码：\n&lt;template', 'http://img.mrqinzh.info/vue.png', '2021-05-10 11:01:56', '2021-09-17 21:06:20', '## Vue + ElementUI实现表格及分页\n\n### 介绍\n主要实现的功能有： 数据添加、删除、以及多行删除。\n因为没有连接后台，所有不能保证数据的持久性。\n\n图片预览：\n ![image.png](http://47.108.209.62:9090/files/20210510/18156c40-dcc0-4d3d-a2ca-791b43353d5d_image.png)\n\n实现代码：\n\n```html\n<template>\n  <div id=\"allData\">\n    <!-- 头部工具栏 -->\n    <div class=\"head-row\" style=\"float: right;margin-bottom: 10px;\">\n      <el-button type=\"primary\" icon=\"el-icon-circle-plus-outline\" @click=\"dialogFormVisible = true;addOrUpdate = \'add\'\">添加记录</el-button>\n      <el-button type=\"danger\" icon=\"el-icon-delete\" @click=\"handleDeleteSome()\">删除选中行</el-button>\n    </div>\n\n      <!-- 表格内容部分 -->\n      <div>\n        <el-table\n          ref=\"multipleTable\"\n          :data=\"tableData\"\n          :border=\"true\"\n          v-loading=\"loading\"\n          @selection-change=\"handleSelectionChange\"\n          style=\"width: 100%\">\n          <el-table-column\n          type=\"selection\"\n          width=\"55\">\n          </el-table-column>\n          <el-table-column\n            prop=\"uid\"\n            label=\"账号\"\n            width=\"180\">\n          </el-table-column>\n          <el-table-column\n            prop=\"name\"\n            label=\"姓名\"\n            width=\"180\">\n          </el-table-column>\n          <el-table-column\n            prop=\"uname\"\n            label=\"昵称\"\n            width=\"180\">\n          </el-table-column>\n          <el-table-column\n            prop=\"sex\"\n            label=\"性别\"\n            width=\"180\">\n          </el-table-column>\n          <el-table-column\n            prop=\"birth\"\n            label=\"生日\"\n            width=\"180\">\n          </el-table-column>\n          <el-table-column\n            prop=\"tel\"\n            label=\"联系方式\"\n            width=\"180\">\n          </el-table-column>\n          <el-table-column\n            prop=\"email\"\n            label=\"电子邮箱\"\n            width=\"180\">\n          </el-table-column>\n          <el-table-column\n            prop=\"address\"\n            label=\"地址\">\n          </el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button\n                size=\"mini\"\n                @click=\"handleEdit(scope.$index, scope.row)\">编辑</el-button>\n              <el-button\n                size=\"mini\"\n                type=\"danger\"\n                @click=\"handleDelete(scope.$index, scope.row)\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n        <el-pagination\n          background\n          layout=\"prev, pager, next\"\n          :page-size=\"pageSize\"\n          :total=\"totalCount\"\n          :current-page=\"currentPage\"\n          @current-change=\"changePageNum\">\n        </el-pagination>\n      </div>\n\n    <!-- 隐藏表单 -->\n    <div>\n      <el-dialog title=\"添加\" :visible.sync=\"dialogFormVisible\">\n        <el-form :model=\"form\">\n          <el-form-item label=\"姓名\" :label-width=\"formLabelWidth\">\n            <el-input v-model=\"form.name\" placeholder=\"请输入用户姓名\" autocomplete=\"off\"></el-input>\n          </el-form-item>\n          <el-form-item label=\"性别\" :label-width=\"formLabelWidth\">\n            <el-radio v-model=\"form.sex\" label=\"男\">男</el-radio>\n            <el-radio v-model=\"form.sex\" label=\"女\">女</el-radio>\n          </el-form-item>\n          <el-form-item label=\"生日\" :label-width=\"formLabelWidth\">\n            <div class=\"block\">\n              <el-date-picker\n                v-model=\"form.birth\"\n                type=\"date\"\n                placeholder=\"选择日期\">\n              </el-date-picker>\n            </div>\n          </el-form-item>\n          <el-form-item label=\"联系方式\" :label-width=\"formLabelWidth\">\n            <el-input v-model=\"form.tel\" placeholder=\"请输入电话号码\" autocomplete=\"off\"></el-input>\n          </el-form-item>\n          <el-form-item label=\"电子邮箱\" :label-width=\"formLabelWidth\">\n            <el-input v-model=\"form.email\" placeholder=\"请输入邮箱\" autocomplete=\"off\"></el-input>\n          </el-form-item>\n          <el-form-item label=\"地址\" :label-width=\"formLabelWidth\">\n            <el-cascader\n            size=\"large\"\n            placeholder=\"请选择地址\"\n            v-model=\"form.address\"\n            :options=\"options\"\n            @change=\"findHomePlace\"\n            :props=\"{ expandTrigger: \'hover\' }\">\n            </el-cascader>\n          </el-form-item>\n        </el-form>\n        <div slot=\"footer\" class=\"dialog-footer\">\n          <el-button @click=\"dialogFormVisible = false\">取 消</el-button>\n          <el-button type=\"primary\" @click=\"dialogFormVisible = false;handleAddOrUpdate(form)\">确 定</el-button>\n        </div>\n      </el-dialog>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { regionData, CodeToText } from \'element-china-area-data\'\nimport { getRequest } from \'../utils/api\';\nexport default {\n      data() {\n        return {\n\n          // 分页\n          totalCount: 0,\n          currentPage: 1,\n          pageSize: 5,\n          \n         \n          tableData: [],  // 表格数据\n          options: regionData, // 级联选择器中的 选项\n          multipleSelection: [], \n          loading: false, // 设置 加载动画\n          dialogFormVisible: false,\n          // 表单项\n          form: {\n            uid: \'\', // 登录账号\n            name: \'\', // 姓名\n            uname: \'\', // 昵称\n            sex: \'男\',\n            tel: \'\',\n            birth: \'\', // 2021-04-02\n            address: \'\',\n            email: \'\',\n          },\n          formLabelWidth: \'100px\',\n          addOrUpdate: \'\',\n        }\n      },\n      // 钩子函数 初始化表格数据\n      mounted() {\n        this.loading = true;\n        this.getData(this.currentPage, this.pageSize);\n      },\n      methods: {\n        // 删除记录触发事件\n        handleDelete(index, row){   \n          this.$confirm(\'此操作将永久删除该文件, 是否继续?\', \'提示\', {\n            confirmButtonText: \'确定\',\n            cancelButtonText: \'取消\',\n            type: \'warning\'\n          }).then((aciton) => {\n            // action分别为confirm（确认），cancel（取消），close（关闭）的时候分别触发回调。\n            if(aciton === \'confirm\'){\n              this.$message({\n                type: \'success\',\n                message: \'删除成功!\'\n              });\n              this.tableData.splice(index,1);    \n            }\n          }).catch(() => {\n                    \n          });\n        },\n        // 点击编辑触发事件\n        handleEdit(index, row){\n          console.log(index);\n          //this.form.name = this.tableData[index].name;\n        },\n        // 点击添加触发事件\n        handleAddOrUpdate(form, index){\n          //console.log(form.date);\n          console.log(this.addOrUpdate);\n          var aLine = {\n            date: this.getDateTime(),\n            name: form.name,\n            sex: form.sex,\n            tel: form.tel,\n            address: this.findHomePlace(),\n          };\n          this.tableData.push(aLine);\n          this.$message({\n            type: \'success\',\n            message: \'添加成功\'\n          });\n          \n        },\n        //获取表格选中行的值\n        handleSelectionChange(val) {\n          this.multipleSelection = val;\n        },\n        // 批量删除事件\n        handleDeleteSome(){\n          if (this.multipleSelection.length !== 0){\n            this.$confirm(\'此操作将永久删除选中的所有文件, 是否继续?\', \'警告\', {\n              confirmButtonText: \'确定\',\n              cancelButtonText: \'取消\',\n              type: \'error\'\n            }).then((aciton) => {\n              if(aciton === \'confirm\'){\n                for (let i=this.tableData.length;i>0;i--) {\n                  for (let j=0;j<this.multipleSelection.length;j++) {\n                    if (this.tableData[i-1] === this.multipleSelection[j]) {\n                      this.tableData.splice(i-1, 1);\n                    }\n                  }\n                };\n                this.$message({\n                  type: \'success\',\n                  message: \'删除成功!\'\n                });\n              }     \n            }).catch(() => {\n              this.$message({\n                  type: \'info\',\n                  message: \'撤销删除!\'\n                });\n            });\n          } else {\n            this.$message(\'请先进行勾选\',\"info\");\n          }\n          \n        },\n\n        changePageNum(val) {\n          this.currentPage = val\n          this.getData(this.currentPage, this.pageSize);\n        },\n\n\n        // 获取添加表单中级联选择器 选中的地区\n        findHomePlace() {\n          var home = \"\";\n          for (let i = 0; i < this.form.address.length; i++) {\n            home += CodeToText[this.form.address[i]];\n          }\n          return home;\n          //console.log(home);  // 地址\n        },\n        // 时间转换\n        getDateTime(){\n          var date = this.form.date;\n          //console.log(date);\n          if (date instanceof Date){\n            var y = date.getFullYear();\n            var m = date.getMonth() + 1;\n            m = m < 10 ? \'0\' + m : m;\n            var d = date.getDate();\n            d = d < 10 ? (\'0\' + d) : d;\n            return y + \'-\' + m + \'-\' + d;\n          }\n        },\n        // 页面初始化 axios获取数据\n        getData(currentPage, pageSize) {\n          getRequest(`/user/alldata/${currentPage}/${pageSize}`).then(resp => {\n            // console.log(resp);\n            this.tableData = resp.data.list;\n            this.totalCount = resp.data.total;\n            this.loading = false;\n          })\n\n        },\n      }\n    }\n</script>\n\n<style>\n</style>\n```', 'vue', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (80, '秦志宏', '1、两数之和（LeetCode）', '两数之和\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元', NULL, '2021-05-12 22:58:30', '2021-05-12 22:58:30', '## 两数之和\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n### 示例\n```txt\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n### 代码\n```java\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(nums[i])){\n                return new int[]{map.get(nums[i]), i};\n            };\n            map.put(target-nums[i], i);\n        };\n        return null;\n    }\n}\n```\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/two-sum', '算法', '原创', 1, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (81, '秦志宏', '单例模式（设计模式）', '单例模式\n单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管', NULL, '2021-05-13 22:22:38', '2021-05-13 22:22:38', '## 单例模式\n\n单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。\n\n### 饿汉式\n```java\npackage com.qin.single;\n\n/**\n *  单例模式 ：  饿汉式\n *  直接 创建对象\n *  问题： 会浪费内存\n */\npublic class HungryMan {\n\n    private HungryMan(){\n\n    }\n\n    private static final HungryMan hungryMan = new HungryMan();\n\n    public static HungryMan getInstance(){\n        return hungryMan;\n    }\n\n    public static void main(String[] args) {\n        HungryMan hungryMan1 = HungryMan.getInstance();\n        HungryMan hungryMan2 = HungryMan.getInstance();\n\n        System.out.println(hungryMan1.hashCode());\n        System.out.println(hungryMan2.hashCode());\n    }\n\n}\n```\n\n### 懒汉式\n```java\npackage com.qin.single;\n\nimport java.lang.reflect.Constructor;\n\n/**\n *  单例模式 ：  懒汉式\n */\npublic class LazyMan {\n\n    // 核心，构造器私有化\n    private LazyMan(){\n\n    }\n\n    /**\n     *  volatile 这里主要是为了 禁止指令重排\n     *  1、保证可见性\n     *  2、不保证原子性\n     *  3、禁止指令重排\n     */\n    private volatile static LazyMan lazyMan;\n\n    // DCL 双检索\n    public static LazyMan getInstance(){\n        if (lazyMan == null){\n            synchronized(LazyMan.class){\n                if (lazyMan == null){\n                    lazyMan = new LazyMan();\n                }\n            }\n        }\n        return lazyMan;\n    }\n\n    public static void main(String[] args) throws Exception {\n//        LazyMan lazyMan1 = LazyMan.getInstance();\n//        LazyMan lazyMan2 = LazyMan.getInstance();\n//        System.out.println(lazyMan1.hashCode());\n//        System.out.println(lazyMan2.hashCode());\n\n        for (int i = 0; i < 100; i++) {\n            new Thread(() -> {\n                LazyMan instance = LazyMan.getInstance();\n            }).start();\n        }\n\n        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);\n        declaredConstructor.setAccessible(true);\n        LazyMan lazyMan1 = declaredConstructor.newInstance();\n        LazyMan lazyMan2 = declaredConstructor.newInstance();\n        System.out.println(lazyMan1 == lazyMan2);\n\n    }\n\n}\n```\n当然，最安全的单例模式，还是选择枚举类吧，因为反射也破坏不了。', '设计模式', '原创', 0, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (82, '秦志宏', 'SpringBoot整合JWT', 'SpringBoot整合JWT\n1、引入maven依赖\n&lt;!-- https://mvnrepository.com/artifact/com.auth0/java-jwt --&gt;\n&lt', 'http://img.mrqinzh.info/springboot.png', '2021-05-15 18:49:14', '2021-09-17 21:08:52', '## SpringBoot整合JWT\n\n1、引入maven依赖\n\n```xml\n<!-- https://mvnrepository.com/artifact/com.auth0/java-jwt -->\n<dependency>\n    <groupId>com.auth0</groupId>\n    <artifactId>java-jwt</artifactId>\n    <version>3.15.0</version>\n</dependency>\n```\n\n2、创建JWT工具类\n\n```java\npackage com.qin.util;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.JWTCreator;\nimport com.auth0.jwt.JWTVerifier;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.interfaces.Claim;\nimport com.auth0.jwt.interfaces.DecodedJWT;\n\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class JWTUtils {\n\n    private static final long EXPIRE_TIME = 1000 * 60 * 60;    // 过期时间 1h\n\n    private static final String TOKEN_SECRET = \"@#%DT$%GDG\";    // 签名秘钥\n\n    /**\n     * 生成 token\n     * 不需要存放用户信息\n     */\n    public static String getToken(){\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"alg\", \"HS256\");\n        map.put(\"typ\", \"JWT\");\n        String token = JWT.create()\n                .withHeader(map)\n                .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRE_TIME)) // 过期时间\n                .sign(Algorithm.HMAC256(TOKEN_SECRET)); // 秘钥\n        System.out.println(token);\n        return token;\n    }\n\n    /**\n     * 生成 token\n     * @param claims 返回token的body中需要存放的信息\n     */\n    public static String getTokenWithClaim(Map<String,String> claims) {\n        JWTCreator.Builder builder = JWT.create();\n        for (Map.Entry<String, String> entry : claims.entrySet()) {\n            builder.withClaim(entry.getKey(), entry.getValue());\n        }\n        builder.withIssuer(\"auth0\")\n               .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRE_TIME)); // 过期时间\n        return builder.sign(Algorithm.HMAC256(TOKEN_SECRET));\n    }\n\n    /**\n     * 验证 token\n     */\n    public static boolean verifyToken(String token){\n        try {\n            JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(TOKEN_SECRET)).withIssuer(\"auth0\").build(); // 创建token验证器\n            jwtVerifier.verify(token);\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * 解析token中存放的用户信息\n     * @param name 需要获取信息的键名 key\n     */\n    public static String parseToken(String token, String name){\n        String res = \"\";\n        DecodedJWT decode = JWT.decode(token);\n        Map<String, Claim> claims = decode.getClaims();\n        if (claims.containsKey(name)) {\n            res = decode.getClaim(name).asString();\n        }\n        return res;\n    }\n\n}\n```\n\n3、创建一个拦截器`TokenInterceptor`，用来验证`token`信息\n\n```java\npackage com.qin.interceptor;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.qin.util.JWTUtils;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.servlet.HandlerInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 添加拦截器， 验证请求信息头中的 token 是否有效\n */\n@Component\npublic class TokenInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws Exception {\n\n        String token = req.getHeader(\"token\");\n        if (token != null) {\n            boolean res = JWTUtils.verifyToken(token);\n            if (res){\n                System.out.println(\"通过拦截器\");\n                return true;\n            }\n        }\n\n        resp.setContentType(\"application/json; charset=utf-8\");\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"403\", \"权限不够\");\n        map.put(\"msg\", \"token为空，或者过期了\");\n        String jsonMsg = new ObjectMapper().writeValueAsString(map);\n        resp.getWriter().write(jsonMsg);\n        return false;\n\n    }\n}\n```\n\n4、将拦截器注册到`WebMvcConfigurer`中\n\n```java\n@Configuration\npublic class WebConfiguration implements WebMvcConfigurer {\n\n    @Autowired\n    private TokenInterceptor tokenInterceptor;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(tokenInterceptor).excludePathPatterns(\"/log\");\n    }\n}\n```\n\n5、创建一个控制器来进行测试\n\n```java\npackage com.qin.controller;\n\nimport com.qin.mapper.UserMapper;\nimport com.qin.pojo.User;\nimport com.qin.util.JWTUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestHeader;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@RestController\npublic class UserController {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @RequestMapping(\"/log\")\n    public Map<String, Object> log(User user){\n        Map<String,Object> result = new HashMap<>(); //封装结果状态及信息\n\n        User userDB = userMapper.login(user);\n        if (userDB == null) {\n            result.put(\"msg\",\"账号或密码错误\");\n            return result;\n        }\n\n        Map<String,String> claim = new HashMap<>(); // 添加到 jwt 的 body 中\n        claim.put(\"username\", userDB.getUsername());\n        claim.put(\"password\", userDB.getPassword());\n        String token = JWTUtils.getTokenWithClaim(claim);\n\n        result.put(\"state\",true);\n        result.put(\"msg\",\"登录成功!!!\");\n        result.put(\"token\",token); //成功返回token信息\n        return result;\n\n    }\n\n    @RequestMapping(\"/test\")\n    public Map<String, Object> test(@RequestHeader(\"token\") String token){\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"username\", \"你的用户名为： \" + JWTUtils.parseToken(token, \"username\"));\n        map.put(\"password\", \"你的密码为： \" + JWTUtils.parseToken(token, \"password\"));\n        return map;\n    }\n\n}\n```\n\n\n\n', 'java,springboot', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (83, '秦志宏', 'SpringBoot发送QQ邮件', 'SpringBoot发送QQ邮件\n实现邮件发送需要两个对象： JavaMailSender + SimpleMailMessage ，有了这两个对象，实现起来就很轻松了。\nSpringBoot实现邮件', 'http://img.mrqinzh.info/springboot.png', '2021-05-16 18:44:11', '2021-09-17 21:08:52', '## SpringBoot发送QQ邮件\n实现邮件发送需要两个对象： `JavaMailSender` + `SimpleMailMessage` ，有了这两个对象，实现起来就很轻松了。\n\n#### SpringBoot实现邮件发送验证码功能\n\n1、首先需要到QQ邮箱中开启SMTP服务，获取一个授权码\n\n![image.png](http://47.108.209.62:9090/files/20210516/38917240-b6d0-4af2-8144-4f3d52b8a7c3_image.png)\n\n2、导入`maven`依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n\n\n\n3、在`application.yml`中编写配置\n\n```yaml\nserver:\n  port: 9090\n\nspring:\n  mail:\n    host: smtp.qq.com # 设置邮箱主机\n    username: 1552589784@qq.com # 设置用户名\n    password: pfhogftiaugdbafg # 设置密码，开启SMTP的授权码\n```\n\n4、先写一个邮件发送的实现类`MaiServiceImpl`\n\n```java\npackage com.qin.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Random;\n\n@Service\npublic class MailServiceImpl {\n\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    @Value(\"${spring.mail.username}\")\n    private String from;\n\n    /**\n     * 发送邮件方法\n     * @param sendTo 邮件接受者的QQ号\n     */\n    public void sendMail(String sendTo){\n        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();\n\n        simpleMailMessage.setFrom(from); // 邮件从哪里发出\n        simpleMailMessage.setTo(sendTo + \"@qq.com\"); // 邮件发给谁 这里还支持群发 setTo(...) 是一个可变长参数\n\n        simpleMailMessage.setSubject(\"验证码\"); // 这里是发送的邮件的标题\n        simpleMailMessage.setText(getVerifyCode()); // 这里是邮件的内容部分\n\n        javaMailSender.send(simpleMailMessage);\n        System.out.println(\"发送了一封邮件！！！\");\n    }\n\n\n    /**\n     * 生成验证码\n     */\n    private String getVerifyCode(){\n        List<Integer> list = new ArrayList<>();\n        Random random = new Random();\n\n        while (list.size() < 5) {\n            list.add(random.nextInt(10)); // 生成各位随机数\n        }\n        Iterator<Integer> iterator = list.iterator();\n        StringBuilder code = new StringBuilder();\n        while (iterator.hasNext()) {\n            code.append(iterator.next());\n        }\n        return code.toString();\n    }\n\n}\n```\n\n5、写一个控制器`MailController`\n\n```java\npackage com.qin.controller;\n\nimport com.qin.service.MailServiceImpl;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@RestController\npublic class MailController {\n\n    @Autowired\n    private MailServiceImpl mailServiceImpl;\n\n    /**\n     * 发送邮件请求\n     * @param qq 接受方的QQ号\n     */\n    @RequestMapping(\"/send/{qq}\")\n    public Map<String, Object> sendMail(@PathVariable(\"qq\") String qq){\n        Map<String, Object> map = new HashMap<>();\n\n        mailServiceImpl.sendMail(qq);\n\n        map.put(\"success\", \"发送成功了\");\n        return map;\n    }\n\n}\n```\n\n#### 测试\n\n这里使用Postman来进行测试： \n\n![image.png](http://47.108.209.62:9090/files/20210516/052aa2a7-d786-413a-8bc5-b3de083d41e3_image.png)\n\n得到返回的结果如下： \n![image.png](http://47.108.209.62:9090/files/20210516/68371c73-ef90-4aeb-bebd-02f14604994f_image.png)\n\n最后在来看看收件箱里的内容吧： \n![image.png](http://47.108.209.62:9090/files/20210516/020262fd-5403-4191-9005-77e435d1995d_image.png)\n\n\n。。。就挺突然的，这样就完成了邮件的发送了。\n\n\n', 'java,springboot', '原创', 4, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (84, '秦志宏', '冒泡排序法', '冒泡排序\n冒泡排序法的名字由来是因为这种方法排序的原理就好像是水中的气泡往水面浮一样。\n原理图\n\n实现代码：\npackage com.mrqinzh.test;\n\n/**\n * 冒泡排序法： 一种基础', NULL, '2021-05-18 16:42:57', '2021-05-18 16:42:57', '## 冒泡排序\n\n冒泡排序法的名字由来是因为这种方法排序的原理就好像是水中的气泡往水面浮一样。\n\n#### 原理图\n![20190805203733425.gif](http://47.108.209.62:9090/files/20210518/1dc206d4-7a77-4c47-a475-0cd9c35e4438_20190805203733425.gif)\n\n#### 实现代码： \n```java\npackage com.mrqinzh.test;\n\n/**\n * 冒泡排序法： 一种基础的 交换排序、稳定排序\n *      思想： 把相邻的两个元素进行比较，当一个元素大于右侧相邻元素时，交换它们的位置；\n *            当一个元素小于或等于右侧相邻元素时，位置不变。\n * 时间复杂度： O(n^2)\n */\npublic class BubbleSort {\n\n    /**\n     * 最原始的方法\n     * 存在的问题： 当经过前几轮排序后，整个数组已经有序了，但是此算法，还会执行后面的循环\n     */\n    public int[] sort(int[] arr) {\n        for (int i = 0; i < arr.length-1; i++) {\n            for (int j = 0; j < arr.length-i-1; j++) {\n                if (arr[j] > arr[j+1]) {  // >：表示从小到大排序     <： 从大到小\n                    int temp = arr[j+1];\n                    arr[j+1] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n        return arr;\n    }\n\n    /**\n     * 优化方案一： {5, 8, 6, 3, 9, 2, 1, 7}\n     *            添加一个标记，当不在执行交换时，证明排序已经完毕，直接跳出\n     */\n    public int[] sortTwo(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            boolean isSorted = true;\n            for (int j = 0; j < arr.length - i - 1; j++) {\n                if (arr[j] > arr[j+1]) {  // >：表示从小到大排序     <： 从大到小\n                    int temp = arr[j+1];\n                    arr[j+1] = arr[j];\n                    arr[j] = temp;\n                    isSorted = false;\n                }\n            }\n            if (isSorted) {\n                break;\n            }\n        }\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        BubbleSort bs = new BubbleSort();\n\n        int[] arr = new int[]{5,88,4,66,77,66,33,48,65,12,78,95,31,45,231,151,46};\n        int[] sort = bs.sortTwo(arr);\n        for (int i : sort) {\n            System.out.print(i + \" \");\n        }\n\n    }\n\n}\n```\n', '算法', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (85, '秦志宏', '快速排序法', '快速排序法\n思路： 快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。\n图解\n\n代码实现\npackage com.mrqinzh.test;\n\nimport ja', NULL, '2021-05-18 17:15:22', '2021-05-18 17:15:22', '## 快速排序法\n思路： **快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。**\n\n#### 图解\n![20190604213342876.jpg](http://47.108.209.62:9090/files/20210518/246a609f-c68c-4009-b9d7-edc11d35f799_20190604213342876.jpg)\n\n#### 代码实现\n```java\npackage com.mrqinzh.test;\n\nimport java.util.Arrays;\n\n/**\n * 快速排序\n * 思想：      （分治法）： 每一轮挑选一个基准元素，并让其他比它大的元素移动\n *            到数列的一边，比它小的元素移动到数列的另一边，从\n *            而把数列拆解成两个部分。\n * 时间复杂度： O(n^2)\n */\npublic class QuickSort {\n\n    public static void sort(int[] arr, int startIndex, int endIndex) {\n        // 递归条件： startIndex大于或等于endIndex时\n        if (startIndex >= endIndex) {\n            return;\n        }\n        // 得到基准元素的位置\n        int pivotIndex = partition(arr, startIndex, endIndex);\n        sort(arr, startIndex, pivotIndex-1);\n        sort(arr, pivotIndex+1, endIndex);\n    }\n\n    /**\n     * 分治（双边循环法）\n     * @param arr           待交换的数组\n     * @param startIndex    起始下标\n     * @param endIndex      结束下标\n     */\n    private static int partition(int[] arr, int startIndex, int endIndex) {\n        // 取第一个位置（也可以随机选取位置）的元素作为基准元素\n        int pivot = arr[startIndex];\n        int left = startIndex;\n        int right = endIndex;\n\n        while (left != right) {\n            // 控制right指针比较并左移\n            while (left<right && arr[right]>pivot) {\n                right--;\n            }\n            // 控制left指针比较并右移\n            while (left<right && arr[left]<=pivot) {\n                left++;\n            }\n            // 交换left和right指针所指向的元素\n            if (left < right) {\n                int p = arr[left];\n                arr[left] = arr[right];\n                arr[right] = p;\n            }\n        }\n        // pivot和指针重合点交换\n        arr[startIndex] = arr[left];\n        arr[left] = pivot;\n\n        return left;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 4, 6, 5, 3, 2, 8, 1};\n        sort(arr, 0, arr.length-1);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```', '算法', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (87, '秦志宏', '203、移除链表元素（LeetCode）', '移除链表元素\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n示例\n示例1：\n输入：head = [1,2', NULL, '2021-06-05 17:45:04', '2021-06-05 17:45:04', '## 移除链表元素\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n\n示例\n```\n示例1：\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n\n示例2：\n输入：head = [], val = 1\n输出：[]\n\n示例3：\n输入：head = [7,7,7,7], val = 7\n输出：[]\n```\n\n代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if (head == null) { \n            return null;\n        }\n        head.next = removeElements(head.next, val); // 遍历当前链表\n\n        return head.val == val ? head.next : head; // 如果链表中当前节点val与参数val相同，则返回链表的下一个节点\n    }\n}\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-linked-list-elements/', '算法', '原创', 0, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (88, '秦志宏', '232. 用栈实现队列（LeetCode）', '请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n实现 MyQueue 类：\nvoid push(int x) 将元素 x 推到队列的末', NULL, '2021-06-08 21:15:16', '2021-06-08 21:15:16', '请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n \n\n说明：\n\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n \n\n进阶：\n\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n\n示例：\n```\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```\n代码：\n```java\npackage com.qin.test;\n\nimport java.util.Stack;\n\npublic class MyQueue {\n\n    Stack<Integer> left = new Stack<>();\n    Stack<Integer> right = new Stack<>();\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        left.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (right.isEmpty()) {\n            while (!left.isEmpty()) {\n                right.push(left.pop());\n            }\n        }\n        return right.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        if (right.isEmpty()) {\n            while (!left.isEmpty()) {\n                right.push(left.pop());\n            }\n        }\n        return right.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return left.isEmpty() && right.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        MyQueue queue = new MyQueue();\n\n        queue.push(1);\n        queue.push(2);\n        System.out.println(queue.peek()); // 返回 1\n        System.out.println(queue.pop()); // 返回 1\n        System.out.println(queue.empty()); // 返回 false\n    }\n\n}\n\n```\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/implement-queue-using-stacks', '算法', '原创', 1, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (89, '秦志宏', '206. 反转链表（LeetCode）', '反转链表\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例：\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n\n代码:\npackage com.qin', NULL, '2021-06-09 16:04:29', '2021-06-09 16:04:29', '## 反转链表\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例：\n```\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n```\n\n代码:\n```java\npackage com.qin.test;\n\n// 反转链表\npublic class ReverseList {\n\n    public static ListNode reverseList(ListNode head) {\n        ListNode pre = null; // 前指针节点\n        ListNode curr = head; // 当前指针节点\n        // 每次循环，都将当前指针节点指向前指针节点，并将两个节点后移\n        while (curr != null) {\n            ListNode next = curr.next; // 临时节点，暂存当前节点的后一位，用于后移\n            curr.next = pre; // 将当前节点指向前面的节点\n            pre = curr; // 前指针后移\n            curr = next; // 当前指针后移\n        }\n        return pre;\n    }\n\n    public static void main(String[] args) {\n        ListNode node = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));\n        ListNode listNode = reverseList(node);\n        System.out.println(listNode);\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(){}\n    ListNode(int val){ this.val = val; }\n    ListNode(int val, ListNode next){ this.val = val; this.next = next; }\n    @Override\n    public String toString() {\n        return \"ListNode{\" +\n                \"val=\" + val +\n                \", next=\" + next +\n                \'}\';\n    }\n}\n```\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/implement-queue-using-stacks', '算法', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (90, '秦志宏', 'ThreadLocal源码分析', 'ThreadLocal\nThread --&gt; ThreadLocalMap --&gt; Entry --&gt; Thread : value\n每个ThreadLocal创建一个ThreadL', 'http://img.mrqinzh.info/java.png', '2021-06-18 13:22:53', '2021-09-17 21:06:06', '### ThreadLocal\n\nThread --> ThreadLocalMap --> Entry --> Thread : value\n\n每个ThreadLocal创建一个ThreadLocalMap，用线程作为Map的Key，要存储的局部变量为Value，达到各个线程局部变量隔离的效果。\n\n\n\nJDK8： \n\n每个Thread维护一个ThreadLocalMap，以ThreadLocal本身作为Map的Key，value为真正要存储的值Object\n\n+ 每个Thread线程内部都有一个Map（ThreadLocalMap）\n+ Map中存储ThreadLocal对象（Key），线程的变量副本（value）\n+ Thread内部的Map是由ThreadLocal维护，由ThreadLocal向Map中获取和设置线程的变量值。\n+ 对于不同的线程，每次获取副本值时，别的线程不能获取当前线程的副本值，形成了副本的隔离，互不干扰。\n\n\n\nJDK早期： \n![image.png](http://47.108.209.62:9090/files/20210618/757dad0c-506c-469e-94b8-fa10c068d255_image.png)\n\nThreadLocal 维护 ThreadLocalMap，以当前Thread为Key\n\n\n\nJDK8： \n![image.png](http://47.108.209.62:9090/files/20210618/f6fdd13b-1c63-4bc2-b0ff-a8e664750700_image.png)\n\nThread 维护 ThreadLocalMap，以当前ThreadLocal为Key\n\n好处： \n\n+ 每个Map存储的Entry数量变少（之前以Thread为key，多少线程就有多少Entry），能尽量避免Hash冲突\n+ 当Thread销毁时，ThreadLocalMap也会随之销毁，减少内存的使用（ThreadLocalMap在Thread里面）\n\n\n\n### ThreadLocal的核心方法源码\n\n对外暴露的方法4个：\n\n| 方法名                     | 描述                         |\n| -------------------------- | ---------------------------- |\n| protected T initialValue() | 返回当前线程局部变量的初始值 |\n| public void set(T value)   | 设置当前线程绑定的局部变量   |\n| public T get()             | 获取当前线程绑定的局部变量   |\n| public void remove()       | 移除当前线程绑定的局部变量   |\n\n\n\n#### set方法：\n\n```java\n/**\n     * 设置当前线程对应的ThreadLocal的值\n     * \n     * @param value： 将要保存在线程对应ThreadLocal的值\n     */\n    public void set(T value) {\n        Thread t = Thread.currentThread(); // 获取当前线程对象\n        ThreadLocalMap map = getMap(t); // 获取当前Thread对象中维护的ThreadLocalMap对象\n        // 判断map是否存在\n        if (map != null)\n            map.set(this, value); // 若存在，调用map.set设置实体Entry\n        else\n            // 1): 当前线程Thread不存在ThreadLocalMap对象\n            // 2): 则调用createMap方法进行ThreadLocalMap对象的初始化\n            // 3): 并将t（当前线程）和value（t对应的值）作为第一个Entry存放至ThreadLocalMap中\n            createMap(t, value);\n    }\n\n/**\n     * 获取当前线程维护的ThreadLocalMap\n     * @param t： 当前线程\n     * @return 对应的map对象\n     */\n    ThreadLocal.ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n\n    /**\n     * 创建当前线程对应的ThreadLocalMap\n     * @param t： 当前线程\n     * @param firstValue： value\n     */\n    void createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocal.ThreadLocalMap(this, firstValue);\n    }\n```\n\n**流程总结：**\n\n1. 首先获取当前线程，并获取其ThreadLocalMap对象\n\n2. 如果获取的map对象不为空，则设置参数，当前线程（key），value（value）\n\n3. 若为空，则创建，并赋初始值\n\n\n\n#### get方法： \n\n```java\n/**\n     * 返回当前线程中保存的ThreadLocal的值\n     * 若当前线程没有ThreadLocalMap变量，则调用setInitialValue()方法，进行初始化\n     *\n     * @return 返回当前线程中保存的ThreadLocal的值\n     */\n    public T get() {\n        Thread t = Thread.currentThread(); // 获取当前线程\n        ThreadLocal.ThreadLocalMap map = getMap(t); // 获取当前线程的ThreadLocalMap对象\n        // 如果当前map存在\n        if (map != null) {\n            ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(this); // 以当前ThreadLocal为Key，调用getEntry获取实体e（Entry对象）\n            // 对Entry对象进行判空\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value; // 获取e的value值\n                return result;\n            }\n        }\n        // 1. map不存在： 表示没有维护的ThreadLocalMap对象\n        // 2. map存在，但没有与当前ThreadLocal关联的Entry对象\n        return setInitialValue();\n    }\n\n    /**\n     * 初始化\n     * @return 初始化后的值\n     */\n    private T setInitialValue() {\n        // 调用initialValue()方法获取初始化后的值\n        // 该方法可以被子类重写，如果不重写，则默认返回null\n        T value = initialValue();\n        Thread t = Thread.currentThread(); // 获取当前Thread\n        ThreadLocal.ThreadLocalMap map = getMap(t); // 获取当前Thread维护的ThreadLocalMap对象\n        // 判断map是否存在\n        if (map != null)\n            map.set(this, value); // 存在： 调用map.set设置此实体Entry\n        else\n            createMap(t, value); // 当前线程不存在对应的ThreadLocalMap对象，调用createMap()创建map对象，并相应设置第一个Entry对象\n        return value; // 返回设置的value值\n    }\n\n    protected T initialValue() {\n        return null;\n    }\n```\n\n**流程总结：**\n\n1. 获取当前线程及对应的ThreadLocalMap对象\n\n2. 对map对象和map中的Entry对象进行判空，若不为空，则返回对应的value\n\n3. 若map为空，或者Entry实体为空，则进行初始化操作\n4. 若map为空，则先调用createMap()方法创建ThreadLocalMap对象，再设置Entry属性\n5. 若Entry对象为空，则直接map.set()设置Entry属性\n\n**先获取当前线程的ThreadLocalMap变量，存在则返回value，不存在则创建并返回value**\n\n\n\n#### remove方法：\n\n```java\n/**\n     * 删除当前线程中保存的ThreadLocalMap对应的Entry实体\n     */\n    public void remove() {\n        ThreadLocal.ThreadLocalMap m = getMap(Thread.currentThread()); // 获取当前线程的ThreadLocalMap对象\n        if (m != null)\n            m.remove(this); // 不为空，以当前ThreadLocal为Key，进行删除\n    }\n```\n\n**流程总结：**\n\n1. 获取当前线程的ThreadLocalMap对象\n2. 如果map不为空，则以当前ThreadLocal为Key移除对应Entry\n\n\n\n### 弱引用与内存泄漏\n\n在ThreadLocal使用中会造成内存泄漏\n\n1. **内存泄漏相关概念**\n\n   + Memory overflow：内存溢出，没有足够的内存提供出来\n   + Memory leak： 内存泄漏： 指程序中已经动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费。\n\n2. **弱引用相关概念**\n\n   + Java中的引用有4中： 强、软、弱、虚\n\n   + **强引用**：最常见的对象引用方式，只要还有强引用指向一个对象，就能表示该对象还存活，不会被垃圾回收器回收\n   + **软引用**： 如果一个对象只具有软引用，如果内存足够，则不会被垃圾回收，内存空间不足时，就会回收这些对象的内存，只要没被回收，就可以在程序中使用。软引用可用来实现内存敏感的高速缓存\n   + **弱引用**： 垃圾回收器一旦发现弱引用对象，不管内存空间足够与否，都会回收它的内存\n   + **虚引用**： 虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。\n   + **虚引用与软引用和弱引用的一个区别**在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解\n\n\n\n> **假设Key使用强引用，还会造成内存泄漏吗？**\n\n![image.png](http://47.108.209.62:9090/files/20210618/7336ef02-8303-48a7-aa84-58d9b194093b_image.png)\n\n1. 假设业务中使用完ThreadLocal，ThreadLcoal的引用Ref被回收了。\n2. 但是由于ThreadLocalMap中的Entry强引用了ThreadLocal，造成ThreadLocal无法被回收。\n3. 在没有手动删除Entry（调用remove方法）以及当前线程Thread仍在运行的情况下，始终有强引用链Thread Ref --> currentThread --> ThreadLocalMap --> Entry，Entry就不会被回收，导致Entry内存泄漏。\n\n\n\n> **Key使用了弱引用，会造成内存泄漏吗？**\n\n![image.png](http://47.108.209.62:9090/files/20210618/41d52b9a-a6f1-4cc6-9082-a572d1f6e48a_image.png)\n\n1. 同样假设业务中使用完ThreadLocal，ThreadLcoal的引用Ref被回收了。\n2. 但是由于ThreadLocalMap只持有ThreadLocal的弱引用，所以ThreadLocal会被gc回收，此时Entry中的key为null。\n3. 在没有手动删除Entry（调用remove方法）以及当前线程Thread仍在运行的情况下，也有强引用链Thread Ref --> currentThread --> ThreadLocalMap --> Entry --> value，而这块value永远不会被访问到，导致value的内存泄漏。\n\n\n\n> **出现内存泄漏的真实原因**\n\n\n\n1. 没有手动删除这个Entry\n   + 在使用完ThreadLocal后，手动remove方法移除，就能避免内存泄漏\n2. currentThread在运行\n   + 由于ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以生命周期和当前Thread一样长，那么在使用完ThreadLocal后，如果当前Thread也执行结束，ThreadLocalMap自然会被gc回收，从根源上避免了内存泄漏。\n\n\n\n> **为什么要设置为弱引用呢？**\n\n在ThreadLcoalMap中的set/getEntry方法中，会对key进行判空，如果为null的话，那么是会对value置为null的。意味着，使用完当前ThreadLocal后，在当前线程仍运行的情况下，**弱引用也比强引用多了一层保障**： 弱引用ThreadLocal会被回收，对用的value在下一次调用set、get、remove方法时会被清除，从而避免内存泄漏。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'java', '原创', 1, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (102, '秦志宏', 'RocketMQ分布式事务', 'RocketMQ分布式事务\n在复杂的系统中——分布式、微服务。由于对数据库进行拆分，那么如何维护操作不同数据库之间的事务问题？\n场景\n转账： A -&gt; B 转账\n两个步骤：\n\nA扣钱\nB加钱\n\n', NULL, '2021-08-30 15:55:42', '2021-08-12 14:33:00', '## RocketMQ分布式事务\n\n在复杂的系统中——分布式、微服务。由于对数据库进行拆分，那么如何维护操作不同数据库之间的事务问题？\n\n### 场景\n\n**转账**： A -> B 转账\n\n两个步骤： \n\n1. A扣钱\n2. B加钱\n\n![image.png](http://img.mrqinzh.info/d89f42ad1f254bcba4814fa9ea9c074d.png)\n\n\n如果是在同一个事务中的话，可以很好的保证两步操作，可以同时成功，或者同时失败，保证了数据的一致性。\n\n**如果不在同一个事务中呢？**\n\n### RocketMQ的解决方案\n\n首先，了解一些基础概念：\n\n1. 最终一致性： 存储系统保证在没有新的更新条件下，最终所有的访问都是最后更新的值。不保证在任意时刻节点上的同一份数据是相同的，但随着时间的变化，不同节点上的数据都朝相同的方向变化。**即在一段时间后，节点间的数据会最终达到一致的状态。**\n2. 强一致性： 系统中的某个数据被更新后，后续任一访问该数据都是得到更新后的值。即**任何一次读数据都能读到其最近一次写后的最新值。**\n3. 半消息（`Half Message`）： **不能被Consumer消费的消息**，指Producer将消息发送到Broker，但此消息对Consumer处于不可见的状态，需要等待Producer的二次确认，才能进行消费。\n4. 消息回查： Producer会扫描长时间处于**半消息**状态的消息，并主动询问Producer，查询该消息的最终状态。\n\n![image.png](http://img.mrqinzh.info/ef63f5a983274fe2b6449ecfae5554bc.png)\n\n```html\n执行流程：\n1. 首先，Producer在执行本地事务前，会发送半消息（Half Message）给到RocketMQ。\n2. Rocket接受到Producer发送来的半消息，返回Producer半消息发送成功。\n3. Producer在得到半消息发送成功的通知后，开始执行本地事务。\n4. Producer再将执行本地事务的结果（commit/rollback）发送给RocketMQ。\n5. RocketMQ会根据接收到的事务结果对半消息进行处理    \n	rollback： 直接丢弃该半消息\n	commit： 投递消息，将该消息供Consumer消费\n6. 如果RocketMQ迟迟未收到该半消息的确认状态，则进行消息回查，询问Producer\n7. Producer接到消息回查后，检查本地事务的状态，返回给RocketMQ\n```\n\n即**只有Producer本地事务执行成功，Consumer才能进行消费**\n\n那么： 如果Producer端事务执行成功了，但在Consumer消费消息时，执行失败了呢。？\n\n### Consumer消费失败重试机制\n\n首先我们要知道： 在RocketMQ消费者消费完一条消息后，需要回复broker该消息的消费状态\n\n其消费状态只有两种：\n\n+ consume_success： 消费成功\n+ consume_later： 稍后重新消费\n\n重试的消息会进入一个 `%RETRY%+ConsumeGroup` 的重试队列中。\n\n然后RocketMQ默认 允许**每条消息的最多重试次数为16** ， 每次重试的时间间隔与延迟消息的延迟级别是对应的。取得是延迟级别得后16级别。\n\n```\n延时级别如下：messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\n```\n\n如果重试16次后仍然失败，该消息将不再投递，转入死信队列。\n\n注：**一条消息无论重复多少次，这些重试消息得MessageId始终一样**\n\n重试次数，也可进行定制，通过`consumer.setMaxReconsumeTimes(int n)`来设置。\n\n> 消息多次重试失败后进入死信队列\n\n​	当一条消息消费失败，RocketMQ会自动进行消息重试，如果消息重试次数超过最大重试次数，则RocketMQ将认为该消息存在问题。但此时，RocketMQ不会直接丢弃该消息，而会将其发送到这个消费者组对应的一种特殊队列： 死信队列  `%DLQ%+ConsumeGroup`。\n\n\n\n### 分布式事务实现代码案例\n\n该代码处理的是本文最初的场景。\n\n##### 首先由Producer发送半消息\n\n```java\npublic void test() {\n    // 单次转账唯一编号\n    String businessNo = UUID.randomUUID().toString();\n\n    // 要发送的事务消息，设置转账人，被转账人，转账金额\n    TransferRecord transferRecord = new TransferRecord();\n    transferRecord.setFromUserId(1L);\n    transferRecord.setToUserId(2L);\n    transferRecord.setChangeMoney(100L);\n    transferRecord.setRecordNo(businessNo);\n\n    try {\n        Message msg = new Message(\"TransanctionMessage\", \"tag\", businessNo,\n                                  JSON.toJSONString(transferRecord).getBytes(RemotingHelper.DEFAULT_CHARSET));\n        // Producer 发送Half Message\n        SendResult sendResult = producer.sendMessageInTransaction(msg, null);\n        System.out.println(\"prepare事务消息发送结果: \" + sendResult.getSendStatus());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n```\n\n\n\n##### RocketMQ回复是否接受半消息后，开始执行本地事务。并根据本地事务的执行结果，判断是否提交该消息供Consumer消费\n\n```java\n/**\n* RocketMQ 收到Half Message 后，开始执行本地事务\n* @return 本地事务执行结果状态\n*/\n@Override\npublic LocalTransactionState executeLocalTransaction(Message msg, Object arg) {\n    TransferRecord transferRecord = JSON.parseObject(msg.getBody(), TransferRecord.class);\n    LocalTransactionState state = LocalTransactionState.UNKNOW;\n    try {\n        // 进行本地事务操作\n        boolean isCommit = businessService.doTransfer(transferRecord.getFromUserId(),transferRecord.getToUserId()                                                ,transferRecord.getChangeMoney(),transferRecord.getRecordNo(),msg.getTransactionId());\n        // 提交本地事务操作结果\n        if (isCommit) {\n            state = LocalTransactionState.COMMIT_MESSAGE;\n        } else {\n            state = LocalTransactionState.ROLLBACK_MESSAGE;\n        }\n    } catch (Exception e) {\n        System.out.println(\"转账失败, fromUserId: \" + transferRecord.getFromUserId() + \", toUserId: \" + transferRecord.getToUserId() + \", money: \" + transferRecord.getChangeMoney());\n        e.printStackTrace();\n    }\n    return state;\n}\n```\n\n\n\n##### 其中获取本地事务的执行结果方法\n\n```java\n/**\n* 转账操作 A扣钱，同时新增转账明细\n*\n* @param fromUserId    转账人id\n* @param toUserId      收账人id\n* @param changeMoney   转账金额\n* @param businessNo    单次转账唯一业务标识\n* @param transactionId 事务消息事务id\n* @return 转账行为结果\n*/\n@Transactional(rollbackFor = Exception.class)\npublic boolean doTransfer(Long fromUserId, Long toUserId, Long changeMoney, String businessNo, String transactionId) {\n    TransferRecord transferRecord = new TransferRecord();\n    transferRecord.setFromUserId(fromUserId);\n    transferRecord.setChangeMoney(changeMoney);\n    transferRecord.setTransactionId(transactionId);\n    transferRecord.setToUserId(toUserId);\n    transferRecord.setRecordNo(businessNo);\n\n    // 向transaction_log中插入一条记录，防止消息重复发送，导致本地事务多次执行，重复扣钱\n    transferRecordMapper.insert(transferRecord);\n\n    // 执行A扣钱操作\n    int result = userMapper.reduceMoney(fromUserId, changeMoney);\n    if (result <= 0) {\n        throw new BizException(\"A账户余额不足\");\n    }\n\n    System.out.println(\"转账成功, fromUserId:\" + fromUserId + \", toUserId:\" + toUserId+\", money:\" + changeMoney);\n    return true;\n}\n```\n\n\n\n##### 最后附上消息回查方法、已经Consumer的代码\n\n**消息回查**\n\n```java\n/**\n* 消息回查： 检查本地事务结果\n* @param msg\n* @return\n*/\n@Override\npublic LocalTransactionState checkLocalTransaction(MessageExt msg) {\n    LocalTransactionState state = LocalTransactionState.UNKNOW;\n    try {\n        // 去transaction_log中寻找有无记录，true：表示本地事务执行成功 false：失败\n        boolean isCommit = businessService.checkTransferStatus(msg.getTransactionId());\n        if (isCommit) {\n            state = LocalTransactionState.COMMIT_MESSAGE;\n        } else {\n            state = LocalTransactionState.ROLLBACK_MESSAGE;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return state;\n}\n```\n\n**检查本地事务**\n\n```java\n/**\n* 检查扣钱操作执行状态\n*\n* @return 是否存在对应 transactionId 的转账记录\n*          true： 说明A扣钱执行成功，因为A扣钱与transaction_log添加记录是在同一个事务中的\n*          false： A扣钱操作失败，事务rollback\n*/\npublic boolean checkTransferStatus(String transactionId) {\n    return transferRecordMapper.selectCount(new QueryWrapper<>(new TransferRecord().setTransactionId(transactionId))) > 0;\n}\n```\n\n\n\n**Consumer**\n\n```java\npublic static void main(String[] args) throws InterruptedException, MQClientException {\n    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"please_rename_unique_group_name_4\");\n    consumer.setNamesrvAddr(\"127.0.0.1:9876\");\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    consumer.subscribe(\"TransanctionMessage\", \"*\");\n    consumer.registerMessageListener(new MessageListenerConcurrently() {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                        ConsumeConcurrentlyContext context) {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"收到消息,\" + new String(msg.getBody()));\n                //Todo B加钱操作\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    });\n    consumer.start();\n    System.out.printf(\"Consumer Started.%n\");\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'RocketMQ,分布式事务', '原创', 8, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (103, '秦志宏', '876.链表的中间节点（leetCode）', '链表的中间节点\n\n题意\n\n给定一个头结点为 head 的非空单链表，返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例1：\n输入：[1,2,3,4,5]\n输出：此列表中的结点 3 ', NULL, '2021-08-15 15:36:18', '2021-08-15 15:36:18', '## 链表的中间节点\n> 题意\n\n给定一个头结点为 head 的非空单链表，返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n示例1：\n```\n输入：[1,2,3,4,5]\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n```\n\n示例2：\n```\n输入：[1,2,3,4,5,6]\n输出：此列表中的结点 4 (序列化形式：[4,5,6])\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n```\n\n> 解决思路\n\n快慢指针\n\n> 代码示例\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        ListNode slow = head.next;\n        ListNode fast = head.next;\n        while(fast.next != null && fast.next.next !=null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/middle-of-the-linked-list', '算法,链表', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (104, '秦志宏', '234.回文链表（LeetCode）', '回文链表\n\n题意\n\n请判断一个链表是否为回文链表。\n示例1：\n输入: 1-&gt;2\n输出: false\n\n示例2：\n输入: 1-&gt;2-&gt;2-&gt;1\n输出: true\n\n\n解决思路\n\n', NULL, '2021-08-15 15:50:14', '2021-08-15 15:50:14', '## 回文链表\n> 题意\n\n请判断一个链表是否为回文链表。\n示例1：\n```\n输入: 1->2\n输出: false\n```\n示例2：\n```\n输入: 1->2->2->1\n输出: true\n```\n> 解决思路\n\n先创建一个栈，先对链表进行遍历，将其每个元素压入栈中，再重新遍历链表，将栈中元素依次出栈，进行比对\n> 代码\n```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        Stack<ListNode> stack = new Stack<ListNode>();\n        ListNode curr = head;\n        while(curr != null) {\n            stack.push(curr);\n            curr = curr.next;\n        }\n        while(head != null) {\n            if(head.val != stack.pop().val) {\n                return false;\n            }\n            head = head.next;\n        }\n        return true;\n    }\n}\n```\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-linked-list/', '算法,链表', '原创', 5, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (108, '秦志宏', '19. 删除链表的倒数第 N 个结点', '删除链表的倒数第 N 个结点\n\n题意\n\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例1：\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]', NULL, '2021-08-17 22:02:07', '2021-08-17 22:02:07', '## 删除链表的倒数第 N 个结点\n> 题意\n\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\n示例1：\n```\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]\n```\n示例2：\n```\n输入：head = [1], n = 1\n输出：[]\n```\n示例3：\n```\n输入：head = [1,2], n = 1\n输出：[1]\n```\n\n> 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        if(head == null || (head.next == null && n > 1)) {\n            return head;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n	// 快指针先走n步，然后快慢指针同时出发，\n	// 当快指针走完时，慢指针的位置就是要删除的位置\n        for(int i=0;i<=n;i++) {\n            if(fast != null) {\n                fast = fast.next;\n            } else {\n                return head.next;\n            }\n        }\n        while(fast != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        slow.next = slow.next.next;\n        return head;\n    }\n}\n```\n\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list', '算法,链表', '原创', 10, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (109, '秦志宏', 'HTTPS协议', '什么是HTTPS\n\n对称加密\n\n\n浏览器与客户端公用同一个密钥，该密钥用于加密一段内容，同时也用于解密这段内容。对称加密优点是加解密效率高，但是安全存在问题，因为密钥存放在客户端 有被盗取的风险。\n代', NULL, '2021-08-18 10:30:37', '2021-08-18 10:30:37', '## 什么是HTTPS\n\n> 对称加密\n\n![image.png](http://www.mrqinzh.info:9090/files/20210818/f50862bf77414e3a8c574304777d35be.png)\n\n浏览器与客户端公用同一个密钥，该密钥用于加密一段内容，同时也用于解密这段内容。对称加密优点是加解密效率高，但是安全存在问题，因为密钥存放在客户端 有被盗取的风险。\n\n代表算法： AES、DES等\n\n\n\n> 非对称加密\n\n![image.png](http://www.mrqinzh.info:9090/files/20210818/540914c0bc3f45f3aafd7b141a70c356.png)\n他的密钥分为公钥和私钥两种。公钥存放客户端，私钥放服务器。使用公钥加密的数据只有私钥能解密。非对称加密的优点是安全性更高。但是加密效率比对称加密差很多。\n\n代表算法： RSA、ElGamal等\n\n\n\n### 传统的HTTP传输\n\n在传输数据时，信息都是明文传输的，很容易出现数据被监听和盗取。还有可能存在被篡改，导致浏览器发送的与服务器接收的数据不一致。因此，HTTP是一种不安全的传输协议。\n\n\n\n### HTTPS如何保证安全\n\n> 使用对称加密的情况\n\n能够满足网络传输的效率问题，也能保证数据是密文传输。但是存在一个问题： 浏览器与服务器如何决定使用什么密钥？\n\n因为浏览器和服务器需要使用相同的密钥才能对数据进行加解密，但如何才能使密钥不被监听者获取呢。？因为不管怎么商定，BS首次通信必定是明文的，如果**第一次通信就被拦截了，然后密钥就会泄露给中间人，中间人仍然可以解密后续的所有通信内容。**\n\n\n\n> 使用非对称加密\n\n首先，浏览器与服务器建立通信，服务器将公钥key1发给浏览器，浏览器收到服务端发来的公钥后，自己**用对称加密生成一个密钥key2，并用刚接收的key1对key2进行加密**发送给服务端，服务端利用自己非对称加密的私钥，解开公钥key1的加密，获取key2后，双方就可以使用key2进行加密通信了。在这个过程中，即使中间人，一开始就截获key1，由于不知道私钥是什么，也无法解密了。\n\n存在问题： 中间人虽然不知道私钥是什么，但是**在首次通信，截获服务端的key1后，将其替换成自己生成的一对公钥、私钥，然后把在即生成的公钥返回给浏览器，浏览器并不知道，这个公钥是被替换过的，于是，按照刚刚的流程，先根据对称加密生成的密钥对公钥加密，发送给服务端，这一次通信再被中间人获取，中间人就利用自己的私钥对信息进行解密，就能获取信息中浏览器对称加密生成的密钥**了，然后用一开始 服务端返回的公钥对其进行加密，再返回服务端，这样后面尽管使用了对称加密，但密钥已经在中间人手中了，所以也不安全。\n\n> 证书颁发机构（CA机构）\n\n![image.png](http://www.mrqinzh.info:9090/files/20210818/622bf1b212e34edbb5f7c8d09917daef.png)\n\n流程：\n\n+ 服务端将自己的公钥key1发给CA，向CA申请颁发证书\n+ CA利用自己的私钥来加密key1，并通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密，证书制作完成后，CA将其返回服务端。\n+ 此时浏览器向服务端发起请求时，服务端不再返回自己的公钥，而是将证书返回。\n+ 浏览器收到证书后，第一件事就是验证证书的真假（浏览器和操作系统已经维护了所有权威证书机构的名称和公钥）。所以浏览器只需要知道是哪个机构颁发的证书，就能从本地找出对应的公钥，解密出证书的签名。\n+ 浏览器根据签名规则，自己也生成一个证书签名，如果两个签名一致，则说明证书是有效的，验证成功后，浏览器就可以再次利用机构公钥，解密出服务端的公钥了。\n+ 浏览器自己利用对称加密生成密钥key2，并用服务端的公钥key1对key2进行加密，发给服务器。\n+ 服务器用自己的私钥解开key1，得到key2.之后就可以继续使用key2进行加密通信了。\n\n', '网络,HTTPS', '原创', 9, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (110, '秦志宏', '21. 合并两个有序链表(LeetCode)', '合并两个有序链表\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例一：\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1', NULL, '2021-08-19 14:25:44', '2021-08-19 14:25:44', '## 合并两个有序链表\n\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n示例一： \n\n```\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n示例二：\n\n```\n输入：l1 = [], l2 = []\n输出：[]\n```\n\n示例三： \n\n```\n输入：l1 = [], l2 = [0]\n输出：[0]\n```\n\n\n\n> 代码实现\n```java\n/**\n     * Definition for singly-linked list.\n     * public class ListNode {\n     *     int val;\n     *     ListNode next;\n     *     ListNode() {}\n     *     ListNode(int val) { this.val = val; }\n     *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n     * }\n     */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        } else if (l2 == null) {\n            return l1;\n        } else if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists', '算法,链表', '原创', 19, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (111, '秦志宏', 'HTTP状态码介绍', 'HTTP状态码\n当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应', NULL, '2021-08-22 14:26:00', '2021-08-22 14:26:00', '## HTTP状态码\n\n当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。\n\n常见的状态码： \n\n+ 200 - 请求成功\n+ 301 - 资源被转移到其他URL（重定向）\n+ 404 - 请求资源不存在（URL错误）\n+ 500 - 内部服务器错误\n\n\n\n### HTTP状态码分类\n\nHTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\n\n| 分类 | 分类描述                                       |\n| ---- | ---------------------------------------------- |\n| 1**  | 信息，服务器收到请求，需要请求继续执行操作     |\n| 2**  | 成功，操作被成功接收并处理                     |\n| 3**  | 重定向，需要进一步的操作以完成请求             |\n| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |\n| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |\n\n\n\n#### 常见HTTP状态码列表:\n\n| 状态码 | 描述                                                         |\n| ------ | ------------------------------------------------------------ |\n| 200    | 请求成功。一般用于GET与POST请求                              |\n| 201    | 已创建。成功请求并创建了新的资源                             |\n| 202    | 已接受。已经接受请求，但未处理完成                           |\n| 300    | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |\n| 301    | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |\n| 302    | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |\n| 303    | 查看其它地址。与301类似。使用GET和POST请求查看               |\n| 400    | 客户端请求的语法错误，服务器无法理解                         |\n| 401    | 请求要求用户的身份认证                                       |\n| 403    | 服务器理解请求客户端的请求，但是拒绝执行此请求               |\n| 404    | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 |\n| 405    | 客户端请求中的方法被禁止                                     |\n| 415    | 服务器无法处理请求附带的媒体格式                             |\n| 500    | 服务器内部错误，无法完成请求                                 |\n| 501    | 服务器不支持请求的功能，无法完成请求                         |\n| 502    | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |\n| 503    | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |\n| 504    | 充当网关或代理的服务器，未及时从远端服务器获取请求           |\n| 505    | 服务器不支持请求的HTTP协议的版本，无法完成处理               |\n\n\n\n更多详情HTTP状态码： https://www.runoob.com/http/http-status-codes.html\n\n', 'HTTP,网络', '原创', 5, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (112, '秦志宏', '20. 有效的括号（LeetCode）', '有效的括号\n给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。', NULL, '2021-08-22 15:17:25', '2021-08-22 15:17:25', '## 有效的括号\n\n给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n+ 左括号必须用相同类型的右括号闭合。\n+ 左括号必须以正确的顺序闭合。\n\n```\n示例 1：\n输入：s = \"()\"\n输出：true\n\n示例 2：\n输入：s = \"()[]{}\"\n输出：true\n\n示例 3：\n输入：s = \"(]\"\n输出：false\n\n示例 4：\n输入：s = \"([)]\"\n输出：false\n\n示例 5：\n输入：s = \"{[]}\"\n输出：true\n```\n> 思路\n\n通过栈先进后出的特性，在右括号进栈时，与栈顶元素进行比较，如果是一对括号，则弹出栈顶元素，依次进行，直到不为一对有效括号时。返回false，最好判断栈是否为空，因为有可能，没出栈完的情况。\n\n> 代码实现\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n\n        Stack<Character> stack = new Stack<>();\n        Map<Character, Character> map = new HashMap<>();\n        // 注意 Character 用单引号\n        map.put(\')\', \'(\');\n        map.put(\']\', \'[\');\n        map.put(\'}\', \'{\');\n        for (Character ch : s.toCharArray()) {\n            if (map.containsKey(ch) && !stack.isEmpty()) {\n                // 若为右括号，则将其与栈顶元素进行比较，相等弹出栈顶元素\n                if (stack.peek().equals(map.get(ch))) {\n                    stack.pop();\n                } else {\n                    return false; // 不等直接返回\n                }\n            } else {\n                stack.push(ch); // 是左括号，添加进栈\n            }\n        }\n        return stack.isEmpty(); // 返回栈中是否为空\n    }\n}\n```\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-parentheses', '算法,栈', '原创', 5, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (113, '秦志宏', '垃圾回收器', '垃圾回收器\nCMS\nCMS（Concurrent Mark Sweep）收集器，它能够实现和用户线程并行进行，基于标记清理算法。\n标记清理算法会产生垃圾碎片，为什么CMS还要采用呢。？\n\n因为CMS是', 'http://img.mrqinzh.info/jvm.png', '2021-08-23 11:24:28', '2021-09-17 21:09:18', '## 垃圾回收器\n\n### CMS\n\nCMS（Concurrent Mark Sweep）收集器，它能够实现和用户线程并行进行，基于**标记清理算法**。\n\n标记清理算法会产生垃圾碎片，为什么CMS还要采用呢。？\n\n+ 因为CMS是并发执行的收集器，用户线程执行时，不能改变堆中对象的内存地址！！！，否则用户线程无法获取对象的引用，从而无法正常运行。而标记整理、复制算法 都会移动存活的对象！！！\n\n过程：\n\n+ **初始标记（CMS initial mark）**\n  + 标记GC Roots能直接关联的对象（并不是所有对象），速度快，停顿时间短\n+ **并发标记（CMS concurrent mark）**\n  + 进行GC Roots Tracing的过程，标记出**GC Roots关联到的对象的引用对象有哪些**。比如说 A -> B (A 引用 B，假设 A 是 GC Roots 关联到的对象)，那么这个阶段就是标记出 B 对象， A 对象会在初始标记中标记出来。\n+ **重新标记（CMS remark）**\n  + 修正并发标记期间，用户程序运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记时间长\n+ **并发清除（CMS concurrent sweep）**\n  + 执行标记-清除算法。。\n\n其中初始标记、重新标记这两个步骤会触发`stop the world`，但是执行速度很快，并且并发标记和并发清除这两个过程相对长一点，而且刚好这两个过程又可以和用户线程一起并发执行。所以，把CMS当作是不需要`stop the world`的。\n\n> stop the world （STW）\n\n即在执行垃圾回收算法时，Java引用程序中除了垃圾收集器线程外，其他线程都将被挂起。此时，系统只允许GC线程执行，等待GC线程执行完，其他线程才会继续执行。这些操作是虚拟机在后台自动发起的，对用户不可见。\n\n> 浮动垃圾\n\n由于CMS并发清理阶段，用户线程还在运行，自然就会产生新的垃圾，这部分垃圾出现时，CMS无法在本次垃圾回收时处理它们，只能在下一次GC中再清理。\n\n优点： 并发收集、低停顿。\n\n缺点： \n\n+ CMS在并发阶段，虽然不会导致用户线程停顿，但会占用部分用户线程导致程序运行速度变慢，系统吞吐量降低。\n+ CMS收集器无法处理浮动垃圾，可能会出现`Concurrent Mode Failure`（并发模式故障），一旦出现了`Concurrent Mode Failure`，便会开启后备方案，临时使用SerialOld收集器进行收集工作。\n+ CMS是一款==标记--清除算法==实现的收集器，容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。\n\n> Concurrent Mode Failure\n\n由于其他垃圾回收器都是 `stop the world`，那么内存不够了就执行 GC。但是 CMS 垃圾回收器是可以和用户线程一起并发的，因此 CMS 需要预留一些内存给并发的时候用户线程使用。当预留的内存不够时，报`Concurrent Mode Failure`\n\n\n\n> CMS出现Full GC的原因\n\n+ 年轻代晋升到老年代没有足够的连续空间，很有可能是内存碎片导致的，因此会触发FULL GC\n+ 在并发过程中JVM觉得在并发过程结束之前堆就会满，需要提前触发FullGC\n\n\n\n### G1\n\nG1收集器是一个面向服务端的垃圾收收集器，适用于多核处理器、大内存容量的服务端系统。\n它满足短时间GC停顿的同时达到一个高的吞吐量。JDK7以上版本适用。\n\n> 设计目标\n\n+ 与用户线程同时工作，几乎不需要`stop-the-world`\n+ 整理剩余空间,不产生内存碎片\n+ GC停顿更加可控\n+ 不牺牲系统的吞吐量\n+ gc不要求额外的内存空间\n\n\n\n> G1对堆（Heap）的划分\n\n![image.png](http://img.mrqinzh.info/7bd939b35cd14d09b28a3e4874df8a4b.png)\n\n+ **Heap被划分为一个个相等的不连续的内存区域**（regions），每个region都有一个分代的角色:eden、survivor、old\n+ 对**每个角色的数量并没有强制的限定**，也就是说对每种分代内存的大小，可以动态变化\n+ 高效执行回收，优先去执行那些大量对象可回收的区域（region）\n+ G1使用了GC停顿可预测的模型，来满足用户设定的GC停顿时间，根据用户设定的目标时间，G1会自动的选择哪些region要清除，一次清除多少个region\n+ **G1从多个region中复制存活的对象，然后集中放入一个region中，同时整理、清除内存**\n\n\n\n> G1运作步骤\n\n+ 初始标记\n+ 并发标记\n+ 最终标记\n+ 筛选回收\n  + 对每个region里的回收对象价值（回收该区域的时间消耗和能得到的内存比值）最后进行排序，用户可以自定义停顿时间，那么G1就可以对部分的region进行回收！这使得停顿时间是用户自己可以控制的\n\n初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短，并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。\n\n注： **每个region之间是有互相引用的依赖关系的！这导致在MinorGC的时候会同时对老年代进行扫描（甚至是整个堆扫描），那就会导致MinorGC的效率低下，时间变长**\n\nG1维护一个Remembered Set集合来存放各个Region之间的引用关系。当GC Roots Tracing的时候，只扫描Remembered Set就行了，不用进行全堆扫描了。', 'JVM,Java', '原创', 8, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (114, '秦志宏', '垃圾回收算法', 'JVM四种垃圾回收算法\n复制算法\n它将内存按容量划分为大小相等的两部分，每次只使用其中的一部分，当这部分内存空间使用完后，就将还存活的对象复制到另一部分内存空间去，然后将刚使用的内存空间清理掉。\n\n优', 'http://img.mrqinzh.info/jvm.png', '2021-08-29 16:54:23', '2021-09-17 21:09:18', '## JVM四种垃圾回收算法\n\n### 复制算法\n\n它将内存按容量划分为大小相等的两部分，每次只使用其中的一部分，当这部分内存空间使用完后，就将还存活的对象复制到另一部分内存空间去，然后将刚使用的内存空间清理掉。\n\n![image.png](http://img.mrqinzh.info/435a7baffb304758bb4fdfd88c7c8b78.png)\n\n优点：\n\n+ 标记阶段和复制阶段可以同时进行\n+ 每次只对一块内存进行回收，高效\n+ 不会产生内存碎片\n\n缺点：\n\n+ 需要准备两个大小相等的内存空间，并且只使用其中一块，造成内存浪费\n\n\n\n### 标记-清除算法\n\n标记清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段\n\n在标记阶段，首先通过GC Roots，标记所有从根节点开始所引用的对象**（可达性分析）**，没被标记的对象就是未被引用的垃圾对象，然后在清除阶段，清除所有没被标记的对象。\n\n![image.png](http://img.mrqinzh.info/c1a721a390b9455b85f5ebb13ee36281.png)\n\n优点： \n\n+ 不需要对对象进行移动\n+ 只对不存活的对象进行处理，存活对象较多的情况下比较高效\n\n缺点： \n\n+ 要扫描两次（第一次：标记；第二次：清理）\n+ 会产生内存碎片，导致提前出发下一次垃圾回收\n\n\n\n### 标记-整理算法\n\n首先，也是从GC Roots出发，对所有可达的对象进行一次标记，并且将存活的对象整理到内存的一端，然后清理另一端的垃圾。\n\n![image.png](http://img.mrqinzh.info/6ca67432c7af4ff282e44a8053a165b5.png)\n\n\n优点： \n\n+ 不会产生内存碎片\n\n缺点： \n\n+ GC时间变成，需要将存活的对象转移，并更新引用的地址\n\n\n\n### 分代收集算法\n\n分代收集算法将堆内存分为新生代，老年代，永久代。新生代又被进一步划分为Eden和Survivor ，Survivor由from和to两部分组成。在不同的年代使用不同的算法。\n\n**新生代**：几乎所有新创建的对象都是先进入年轻代，新生代内存按照8：1：1的比例划分为一个Eden和Survivor的from和to。当新生成对象时，现在Eden中申请分配内存，如果内存申请失败，则发起一次GC，进行复制算法，将from中存活的对象复制到to中去，并交换from和to，再将新对象放入。即新生代使用的是复制算法。\n\n**老年代**： 在新生代中经历了15（默认15次，可以通过JVM参数设置大小）次垃圾回收后仍然存活的对象，就会被放到年老代中。老年代的内存比新生代大很多（大概 1：2），当老年代内存满时触发  Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率高。老年代对象存活率高，没有额外空间对它进行分配担保，所以使用标记-清除或者标记-整理算法。\n\n**永久代**： 用于存放静态文件（`class`类、方法）和常量等。在Java8中，用元空间取代了永久代。\n\n', 'java,jvm', '原创', 13, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (115, '秦志宏', 'MySQL explain关键字分析', 'MySQL explain关键字分析\n对explain的各个字段进行详细的分析，可以分析sql是否最佳的使用了索引\n通过explain + sql的方式：\n\n得到查询结果：\n\nid\n可以查看表的读取顺', 'http://img.mrqinzh.info/mysql.png', '2021-08-30 12:12:10', '2021-09-17 21:08:14', '## MySQL explain关键字分析\n\n对explain的各个字段进行详细的分析，可以分析sql是否最佳的使用了索引\n\n通过explain + sql的方式：\n![image.png](http://img.mrqinzh.info/a890e9410f8a4373aca476ac9ecc234f.png)\n\n得到查询结果：\n![image.png](http://img.mrqinzh.info/c04d9e0695434e199aa5f36451a1c8e2.png)\n\n\n### id\n\n可以查看表的读取顺序。表示查询中执行select操作表的顺序。\n\n+ id相同，从上往下执行\n+ id不同，如果是子查询，id会递增，从大到小的执行\n+ id相同和不同同时存在\n\n\n\n### select_type\n\n查询的类型，用于区别 **普通查询、联合查询、子查询等复杂的查询语句**\n\n+ SIMPLE：简单的select查询，查询语句中不包含子查询或UNION\n+ PRIMARY： 在查询语句中包含子查询时，最外层查询会被标记\n+ SUBQUERU： 在select或者where中包含了子查询\n+ DERIVED： 在from中包含的子查询会被标记，MySQL会递归执行这些子查询，并把结果放在临时表中\n+ UNION： 若第二个select出现在UNION之后，会被标记\n+ UNION RESULT： 从UNION表中获取select的结果\n\n\n\n### table\n\n显示这一行的数据是哪一张表的\n\n\n\n### type\n\n显示查询使用了哪种类型：\n\n**system > const > eq_ref > ref > range > index > ALL（从好到坏排列）**\n\n一般来说，要保证查询至少达到range级别，最好能达到ref\n\n+ system： 表只有一行记录（等于系统表）\n+ const： 表示通过索引一次就找到，用于比较primary key和unique索引。因为只匹配一行数据，所以很快\n+ eq_ref： 刚好只有一条记录匹配。唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描\n+ ref： 匹配单值所有行，非唯一性索引扫描，返回匹配某个单独值的所有行\n+ range： 只检索给定范围的行，使用一个索引来进行选择。一般是在where后使用了between、<、>、in等的查询中\n+ index： index与ALL的区别未index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小\n+ ALL： 全表扫描\n\n\n\n### possible_keys\n\n可能引用的索引，显示可能引用到这张表的索引，一个或多个。查询涉及到的字段上若存在索引，则将该索引列出，**但不一定被实际使用**\n\n\n\n### key\n\n实际使用的索引。如果为NULL，则没有使用索引，查询中若使用了覆盖索引，则该索引仅出现在key列表中\n\n\n\n### key_len\n\n表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的\n\n\n\n### ref\n\n**显示哪些索引被实际使用**。显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查询索引列上的值\n\n\n\n### rows\n\n**每张表有多少行被优化器查询**。根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数\n\n\n\n### Extra\n\n+ Using filesort： 说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引进行读取。MySQL中无法利用索引完成的排序操作成为“文件排序”\n+ Using temporary： 比Using filesort更坏。使用了临时表保存中间结果，MySQL在对查询结果排序时使用了临时表。常见于order by和group by\n+ Using index： 表示相应的select操作中使用了覆盖索引，避免了访问表的行数据，效率不错。如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有出现，表明索引用来读取数据而非执行查找动作\n+ Using where： 表示使用了where过滤\n+ Using join buffer： 表示使用了连接缓存\n+ impossible where： where子句的值总是false，不能用来获取任何元组\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 'MySQL', '原创', 5, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (116, '秦志宏', '剑指 Offer 06. 从尾到头打印链表', '从尾到头打印链表\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n\n示例 1：\n\n输入：head = [1,3,2]\n输出：[2,3,1]\n\n方法一\n\n解题思路\n\n先将链表遍历，', NULL, '2021-08-31 10:36:28', '2021-08-31 10:21:30', '## 从尾到头打印链表\n\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n\n>  示例 1：\n\n```\n输入：head = [1,3,2]\n输出：[2,3,1]\n```\n### 方法一\n> 解题思路\n\n先将链表遍历，依次压入栈中。再通过栈先进后出的特点，依次出栈，导入数组\n\n> 代码实现\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] reversePrint(ListNode head) {\n        Stack<Integer> stack = new Stack<>();\n        int count = 0;\n        ListNode node = head;\n        while(node != null) {\n            stack.push(node.val);\n            node = node.next;\n            count++;\n        }\n        int[] res = new int[count];\n        for(int i=0;i<count;i++) {\n            res[i] = stack.pop();\n        }\n        return res;\n    }\n}\n```\n\n![image.png](http://img.mrqinzh.info/781a6f27d8a14f1d9ae6aa8ccff19373.png)\n\n\n\n### 方法二\n\n> 解题思路\n\n先将链表反转，再依次遍历将其添加到数组中。\n\n> 代码实现\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int[] reversePrint(ListNode head) {\n        ListNode pre = null;\n        ListNode curr = head;\n        int count = 0;\n        // 反转链表\n        while(curr != null) {\n            ListNode next = curr.next;\n            curr.next = pre;\n            pre = curr;\n            curr = next;\n            count++;\n        }\n        // 初始化返回数组\n        int[] res = new int[count];\n        for(int i=0;i<count;i++) {\n            res[i] = pre.val;\n            pre = pre.next;\n        }\n        return res;\n    }\n}\n```\n\n![image.png](http://img.mrqinzh.info/2d2dc86864f247feb13c5ea7a63659d2.png)\n\n来源：力扣（LeetCode） \n链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof\n', '算法,链表', '原创', 3, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (117, '秦志宏', '剑指 Offer 10- II. 青蛙跳台阶问题', '剑指 Offer 10- II. 青蛙跳台阶问题\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n答案需要取模 1e9+7（1000000007），', NULL, '2021-09-02 16:27:05', '2021-09-02 16:27:05', '## [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n```html\n示例 1：\n\n输入：n = 2\n输出：2\n示例 2：\n\n输入：n = 7\n输出：21\n示例 3：\n\n输入：n = 0\n输出：1\n```\n\n> 代码实现\n\n```java\nclass Solution {\n    public int numWays(int n) {\n        if(n<=1) return 1;\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i=2;i<=n;i++){\n            dp[i] = (dp[i-1] + dp[i-2])%1000000007;\n        }\n        return dp[n];\n    }\n}\n```\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof', '算法,动态规划', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (118, '秦志宏', '70. 爬楼梯(LeetCode)', '爬楼梯\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n**注意：**给定 n 是一个正整数。\n示例 1：\n\n输入： 2\n输出：', NULL, '2021-09-06 13:32:35', '2021-09-28 16:16:42', '## [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n\n假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**注意：**给定 *n* 是一个正整数。\n\n```html\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n```\n\n\n\n> 代码实现\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        if(n == 1) return 1;\n        if(n == 2) return 2; \n        int[] dp = new int[n+1];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i=3;i<=n;i++) {\n            // 第i阶台阶 = 前i-2台阶的次数 + i-1阶的次数\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n}\n```\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/climbing-stairs', '算法,动态规划', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (119, '秦志宏', '62. 不同路径（LeetCode）', '不同路径\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ', NULL, '2021-09-06 16:38:38', '2021-09-28 16:14:11', '## [不同路径](https://leetcode-cn.com/problems/unique-paths/)\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n![image.png](http://img.mrqinzh.info/c3aba76bb2a14eaf867fe0e52cce440b.png)\n\n```html\n示例 1：\n\n\n输入：m = 3, n = 7\n输出：28\n\n示例 2：\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n```\n\n\n\n> 代码实现\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        // 初始化\n        for (int i=0;i<m;i++) {\n            dp[i][0] = 1;\n        }\n        for (int i=0;i<n;i++) {\n            dp[0][i] = 1;\n        }\n        for (int i=1;i<m;i++) {\n            for (int j=1;j<n;j++) {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]; // 推导\n            }\n        }\n        return dp[m-1][n-1];\n    }\n}\n```\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/unique-paths', '算法,动态规划', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (120, '秦志宏', '64. 最小路径和（LeetCode）', '最小路径和\n给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n**说明：**每次只能向下或者向右移动一步。\n\n示例 1：\n输', NULL, '2021-09-06 16:41:27', '2021-09-28 16:48:11', '## [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n![image.png](http://img.mrqinzh.info/0018f77d14384f38b41937bfb774a6e1.png)\n\n```html\n示例 1：\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n\n示例 2：\n输入：grid = [[1,2,3],[4,5,6]]\n输出：12\n\n```\n\n\n\n> 代码实现\n\n```java\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        int[][] dp = new int[m][n];\n\n        dp[0][0] = grid[0][0]; // 初始化起点\n\n        for(int i=1;i<m;i++) dp[i][0] = dp[i-1][0] + grid[i][0]; // 初始化左边列\n        for(int i=1;i<n;i++) dp[0][i] = dp[0][i-1] + grid[0][i]; // 初始化上边行\n\n        for(int i=1;i<m;i++) {\n            for(int j=1; j<n; j++) {\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j]; // 推导出 dp[m-1][n-1]\n            }\n        }\n\n        return dp[m-1][n-1];\n    }\n}\n```\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-path-sum\n\n', '算法,动态规划', '原创', 1, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (121, '秦志宏', '2. 两数相加（LeetCode）', '两数相加\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了', NULL, '2021-09-08 13:51:19', '2021-09-08 13:51:19', '#### [两数相加](https://leetcode-cn.com/problems/add-two-numbers/)\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n ```html\n示例 1：\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n\n示例 2：\n输入：l1 = [0], l2 = [0]\n输出：[0]\n\n示例 3：\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n ```\n\n> 代码实现\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode root = new ListNode();\n        ListNode curr = root;\n\n        int carry = 0; // 判断是否有进位\n        while (l1 != null || l2 != null || carry != 0) {\n            // 末尾补0\n            int val1 = l1 == null ? 0 : l1.val;\n            int val2 = l2 == null ? 0 : l2.val;\n\n            int sum = val1 + val2 + carry; // 计算当前节点之和，如果有进位，一并相加\n\n            carry = sum / 10;\n\n            ListNode node = new ListNode(sum % 10);\n\n            curr.next = node;\n            curr = curr.next;\n\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n\n        return root.next;\n    }\n}\n```\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/add-two-numbers', '算法,链表', '原创', 0, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (122, '秦志宏', '5. 最长回文子串（LeetCode）', '最长回文子串\n给你一个字符串 s，找到 s 中最长的回文子串。\n示例 1：\n\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案\n\n示例 2：\n输入：s = \"cb', NULL, '2021-09-08 14:59:00', '2021-09-08 14:59:00', '## [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n```html\n示例 1：\n\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案\n\n示例 2：\n输入：s = \"cbbd\"\n输出：\"bb\"\n\n示例 3：\n输入：s = \"a\"\n输出：\"a\"\n\n示例 4：\n输入：s = \"ac\"\n输出：\"a\"\n```\n\n> 代码实现\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        String res = \"\";\n\n        for (int i=0;i<s.length();i++) {\n            String s1 = palindrome(s, i, i);\n            String s2 = palindrome(s, i, i+1);\n\n            res = res.length() > s1.length() ? res : s1;\n            res = res.length() > s2.length() ? res : s2;\n        }\n\n        return res;\n    }\n\n    // 中心扩散\n    public String palindrome(String s, int left, int right) {\n        while (left >= 0 && right<s.length()) {\n            if (s.charAt(left) == s.charAt(right)) {\n                left--;\n                right++;\n            } else break;\n        }\n        return s.substring(left+1, right);\n    }\n}\n```\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring', '算法,双指针', '原创', 1, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (123, '秦志宏', '104. 二叉树的最大深度（LeetCode）', '二叉树的最大深度\n给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n示例：\n给定二叉树 [3,9,20,null,nu', NULL, '2021-09-08 15:07:50', '2021-09-08 15:07:50', '#### [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n```html\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。\n```\n\n> 代码实现\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        // 分别求左右子树的深度 （深度优先搜索）\n        if (root == null) {\n            return 0;\n        } else {\n            int left = maxDepth(root.left);\n            int right = maxDepth(root.right);\n            return Math.max(left, right) + 1;\n        }\n    }\n}\n```\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree', '算法,深度优先搜索', '原创', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (124, '秦志宏', '704. 二分查找（LeetCode）', '二分查找\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n输入', NULL, '2021-09-08 15:22:38', '2021-09-08 15:22:38', '## [二分查找](https://leetcode-cn.com/problems/binary-search/)\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n```html\n示例 1:\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n\n示例 2:\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n```\n\n> 代码实现\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left)/2;\n            if (nums[mid] > target) {\n                right = mid - 1; // target 在左区间，所以[left, mid - 1]\n            } else if (nums[mid] < target) {\n                left = mid + 1; // target 在右区间，所以[mid + 1, right]\n            } else return mid;\n        }\n         // 未找到目标值\n        return -1;\n    }\n}\n```\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/binary-search', '算法,查找', '原创', 3, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (125, '秦志宏', '83. 删除排序链表中重复元素（LeetCode）', '83. 删除排序链表中的重复元素（LeetCode）\n存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。\n返回同样按升序排列的结果链表。\n\n', NULL, '2021-09-08 15:43:27', '2021-09-08 15:43:27', '#### [83. 删除排序链表中的重复元素（LeetCode）](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)\n\n存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除所有重复的元素，使每个元素 **只出现一次** 。\n\n返回同样按升序排列的结果链表。\n\n![image.png](http://img.mrqinzh.info/d95a068d3d4146dcacda734836e219bd.png)\n\n\n\n> 代码实现\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode curr = head;\n        while (head.next != null) {\n            // 如果当前节点的值 == 下一节点值时，更改下个节点指向\n            if (head.val == head.next.val) head.next = head.next.next;\n            else head = head.next;\n        }\n        return curr;\n    }\n}\n```\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list\n\n', '算法,链表', '原创', 5, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (126, '秦志宏', 'Vue二次封装组件', 'Vue二次封装组件\n在web开发中，很多地方使用会使用到相同的组件，因此为了避免代码冗余。我们可以对一些组件进行二次封装。\n这里以封装ElementUI的文件上传为例\n首先，创建组件ImgUpload.vue\n', 'http://img.mrqinzh.info/vue.png', '2021-10-14 16:54:05', '2021-10-14 16:54:05', '## Vue二次封装组件\n\n在web开发中，很多地方使用会使用到相同的组件，因此为了避免代码冗余。我们可以对一些组件进行二次封装。\n\n这里以封装ElementUI的文件上传为例\n\n首先，创建组件ImgUpload.vue\n\n```html\n<template>\n  <el-upload\n  class=\"my-uploader\"\n  :action=\"baseUrl + \'/file/add\'\"\n  :show-file-list=\"false\"\n  :data=\"upLoadData\"\n  :headers=\"headers\"\n  :on-success=\"upLoadSuccess\"\n  :before-upload=\"beforeUpload\">\n    <img v-if=\"imageUrl\" :src=\"imageUrl\" class=\"width: 100%;height: 100%;\">\n    <i v-else class=\"el-icon-plus my-uploader-icon\"></i>\n  </el-upload>\n</template>\n```\n\n```javascript\n<script>\nimport store from \'@/store\';\n  export default {\n    props: {\n      img: \'\',\n    },\n    data() {\n      return {\n        baseUrl: process.env.VUE_APP_BASE_API,\n\n        imageUrl: \'\',\n\n        upLoadData: {\n          file: \'\',\n        },\n\n        headers: {\n          token: store.getters.token,\n        }\n      };\n    },\n    methods: {\n      upLoadSuccess(resp) {\n        this.imageUrl = resp.data;\n        this.$emit(\"uploadimg\", resp);\n        this.$message.success(\"上传成功\");\n      },\n      beforeUpload(file) {\n        const isLt2M = file.size / 1024 / 1024 < 2;\n        if (!isLt2M) {\n          this.$message.error(\'上传图片大小不能超过 2MB!\');\n        }\n        return isLt2M;\n      }\n    }\n  }\n</script>\n```\n\n\n\n这样，在其他地方只需要将其引入，并配置简单的属性，方法，即可。\n\n使用\n\n1. 先将组件引入\n\n```js\nimport ImgUpload from \'@/components/web/upload/ImgUpload\'\n```\n\n2. 定义组件\n\n```js\ncomponents: {\n    ImgUpload,\n},\n```\n\n3. 使用\n\n```html\n<!-- 图片上传组件 -->\n          <img-upload :img=\"articleForm.articleCoverImg\" @uploadimg=\"coverImgUpload\"></img-upload>\n```\n\n只需要定义其需要的对象，和方法即可。\n\n```js\narticleForm.articleCoverImg: \'\',\n\ncoverImgUpload(resp) {\n    this.articleForm.articleCoverImg = resp.data;\n}\n```\n\n', 'Vue,Element-UI', '原创', 7, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (127, '秦志宏', 'vue-admin-template改造', '为vue-admin-template添加tagViews\n为vue-admin-templ', 'http://img.mrqinzh.info/vue.png', '2021-11-02 16:34:29', '2021-11-02 16:34:29', '## 为vue-admin-template添加tagViews\n[为vue-admin-template模板添加tagsview](https://www.cnblogs.com/flypig666/p/11854538.html?tdsourcetag=s_pctim_aiomsg)', 'Vue', '转载', 2, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (128, '秦志宏', 'Spring Security笔记', '\n请求过程\n引入Spring Security后客户端发起请求的流程，如下图所示\n<img src=\"http:/', 'http://img.mrqinzh.info/spring.png', '2021-11-03 16:38:41', '2021-11-03 16:38:41', '![image.png](http://img.mrqinzh.info/de81ad55c0a74fe5853252637b29c018.png)\n## 请求过程\n引入`Spring Security`后客户端发起请求的流程，如下图所示\n![d359fe34bc7860c11a1b6e50bfd0e086.jpg](http://img.mrqinzh.info/261fcbdfb70b4f71a288913a8f89ecba.jpg)\n\n在引入`Spring Security`后，需要重新处理跨域问题，方法如下\n```java\n// 解决跨域问题，cors预检查请求放行，让spring security放行所有cors预检请求\nhttp.cors()\n        .and()\n        .csrf().disable()\n        .authorizeRequests().requestMatchers(CorsUtils::isPreFlightRequest).permitAll();\n```\n\n### 认证流程\n![image20211028162659508.png](http://img.mrqinzh.info/ce41c69ae647495a8dd1bb34a6553255.png)\n\n### 授权过程\n![image20211029083535294.png](http://img.mrqinzh.info/f5ea46516caa42feac16b850ef6177bd.png)\n\n### 三种投票决策器\n```html\n/**\n* 投票决策器：3种\n* AffirmativeBased: 只要有一票同意，即可通过\n* ConsensusBased: 同意 > 反对，即可通过；\n*                 <，抛AccessDeniedException；\n*                 =，具体看allowIfEqualGrantedDeniedDecisions的参数设置，true通过，false抛异常\n* UnanimousBased: 所有投票器均同意才能通过\n*/\n```\n![image.png](http://img.mrqinzh.info/15dde3ee231d496795a54d8fa6b6eca2.png)\n\n', 'Spring', '原创', 4, 1, 0);
INSERT INTO `article` (`id`, `author`, `title`, `summary`, `coverImg`, `updateTime`, `createTime`, `contentMd`, `tag`, `type`, `views`, `userId`, `status`) VALUES (129, '秦志宏', '分布式系统中的CAP理论', '分布式系统中的CAP理论\nCAP 理论指出对于一个分布式计算系统来说，不可能同时满足以下三点：\n\n一致性\n在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性，等同于所有节点访问同一份最新的数据副本。在一致性的需求下，当一个系统在数据一致的状态下执行更新操', 'http://img.mrqinzh.info/b4a010846e1b45fe8e8e724612df21b2.png', '2021-11-04 15:10:26', '2021-11-04 15:10:26', '## 分布式系统中的CAP理论\n\nCAP 理论指出对于一个分布式计算系统来说，不可能同时满足以下三点：\n\n+ **一致性**\n  在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性，等同于所有节点访问同一份最新的数据副本。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。\n+ **可用性**\n  每次请求都能获取到正确的响应，但是不保证获取的数据为最新数据。\n+ **分区容错性**\n  分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。\n\n一个分布式系统**最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项**。\n\n在这三个基本需求中，最多只能同时满足其中的两项，P 是必须的，因此只能在 CP 和 AP 中选择，**zookeeper 保证的是 CP**，对比 spring cloud 系统中的注册中心 **eruka 实现的是 AP**。\n\n\n![image.png](http://img.mrqinzh.info/b1c7a6de6abf4512a76dae5c1ad52f98.png)\n\n\n### BASE 理论\n\nBASE 是 **Basically Available(基本可用)、Soft-state(软状态) 和 Eventually Consistent(最终一致性)** 三个短语的缩写。\n\n+ **基本可用**\n  在分布式系统出现故障，允许损失部分可用性（服务降级、页面降级）。\n+ **软状态**\n  允许分布式系统出现中间状态。而且中间状态不影响系统的可用性。这里的中间状态是指不同的 data replication（数据备份节点）之间的数据更新可以出现延时的最终一致性。\n+ **最终一致性**\n  data replications 经过一段时间达到一致性。\n\nBASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：**我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。**\n\n\n\n', '其他', '转载', 13, 1, 0);
COMMIT;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
                           `id` bigint NOT NULL AUTO_INCREMENT,
                           `avatar` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '头像',
                           `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '昵称',
                           `content` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '评论内容',
                           `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '评论时间',
                           `status` int NOT NULL DEFAULT '0' COMMENT '逻辑删除',
                           `articleId` bigint DEFAULT NULL,
                           `parentId` bigint NOT NULL DEFAULT '0' COMMENT '父评论id',
                           `ip` varchar(150) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'IP地址',
                           `type` int NOT NULL COMMENT '1：评论    2：留言',
                           `updateTime` datetime DEFAULT NULL COMMENT '修改时间',
                           PRIMARY KEY (`id`,`parentId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1825125158267916290 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of comment
-- ----------------------------
BEGIN;
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (1, 'http://mrqinzh.info:9090/img/avatar.jpg', 'mrqinzh', '留言功能上线', '2021-10-13 17:02:17', 0, NULL, 0, '202.98.63.138', 2, NULL);
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (2, 'http://mrqinzh.info:9090/img/random-avatars/avatar7.png', '陈博', '牛牛牛', '2021-10-13 17:02:18', 0, NULL, 0, '202.98.63.138', 2, NULL);
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (3, 'http://mrqinzh.info:9090/img/random-avatars/avatar10.png', '世界无敌美少女', '秦志宏是猪猪', '2021-10-13 17:02:19', 0, NULL, 0, '183.226.63.12', 2, NULL);
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (10, 'http://mrqinzh.info:9090/img/avatar.jpg', 'mrqinzh', '分布式系统中的CAP理论', '2022-03-16 14:36:28', 0, 129, 0, '127.0.0.1', 1, NULL);
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (11, 'http://mrqinzh.info:9090/img/avatar.jpg', '试试', NULL, '2024-08-18 07:40:54', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 07:40:54');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (12, 'http://mrqinzh.info:9090/img/avatar.jpg', '试试', NULL, '2024-08-18 07:41:21', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 07:41:21');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (13, 'http://mrqinzh.info:9090/img/avatar.jpg', '试试', NULL, '2024-08-18 07:41:21', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 07:41:21');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (14, 'http://mrqinzh.info:9090/img/avatar.jpg', '试试12', NULL, '2024-08-18 10:04:19', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 10:04:37');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (15, 'http://mrqinzh.info:9090/img/avatar.jpg', '试试12', NULL, '2024-08-18 10:04:38', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 10:04:50');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (16, 'http://mrqinzh.info:9090/img/avatar.jpg', '试试12', NULL, '2024-08-18 10:04:38', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 10:04:44');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (17, 'http://mrqinzh.info:9090/img/avatar.jpg', '5346', NULL, '2024-08-18 10:41:05', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 10:41:05');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (18, 'http://mrqinzh.info:9090/img/avatar.jpg', '657567', NULL, '2024-08-18 10:42:11', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 10:42:11');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (1825125154870530050, 'http://mrqinzh.info:9090/img/avatar.jpg', '124', NULL, '2024-08-18 10:58:38', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 10:58:38');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (1825125158238556162, 'http://mrqinzh.info:9090/img/avatar.jpg', '124', NULL, '2024-08-18 10:58:41', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 10:58:41');
INSERT INTO `comment` (`id`, `avatar`, `nickname`, `content`, `createTime`, `status`, `articleId`, `parentId`, `ip`, `type`, `updateTime`) VALUES (1825125158267916289, 'http://mrqinzh.info:9090/img/avatar.jpg', '124', NULL, '2024-08-18 10:58:41', 0, NULL, 0, '127.0.0.1', 2, '2024-08-18 10:58:41');
COMMIT;

-- ----------------------------
-- Table structure for file
-- ----------------------------
DROP TABLE IF EXISTS `file`;
CREATE TABLE `file` (
                        `id` bigint NOT NULL AUTO_INCREMENT,
                        `file_name` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '图片名称',
                        `file_path` varchar(200) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '图片路径',
                        `file_type` varchar(10) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '图片类型',
                        `file_create_time` datetime(6) NOT NULL COMMENT '上传时间',
                        `file_size` varchar(30) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '文件大小',
                        `file_place` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '文件存储位置',
                        `status` int NOT NULL DEFAULT '0' COMMENT '0：存在 1：删除',
                        PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=281 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of file
-- ----------------------------
BEGIN;
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (254, 'aee381c22a26482fa20f2f69387f5422.png', '\\files\\20210818', 'png', '2021-08-18 09:51:49.223000', '202.88KB', '本地', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (255, '622bf1b212e34edbb5f7c8d09917daef.png', '/files/20210818', 'png', '2021-08-18 10:24:43.859000', '204.22KB', '本地', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (256, 'f50862bf77414e3a8c574304777d35be.png', '/files/20210818', 'png', '2021-08-18 10:26:15.300000', '230.66KB', '本地', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (257, '540914c0bc3f45f3aafd7b141a70c356.png', '/files/20210818', 'png', '2021-08-18 10:27:35.013000', '156.57KB', '本地', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (258, '7bd939b35cd14d09b28a3e4874df8a4b.png', 'http://img.mrqinzh.info/7bd939b35cd14d09b28a3e4874df8a4b.png', '.png', '2021-08-23 11:23:53.130000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (259, '435a7baffb304758bb4fdfd88c7c8b78.png', 'http://img.mrqinzh.info/435a7baffb304758bb4fdfd88c7c8b78.png', '.png', '2021-08-29 16:50:43.414000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (260, '6ca67432c7af4ff282e44a8053a165b5.png', 'http://img.mrqinzh.info/6ca67432c7af4ff282e44a8053a165b5.png', '.png', '2021-08-29 16:52:31.835000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (261, 'c1a721a390b9455b85f5ebb13ee36281.png', 'http://img.mrqinzh.info/c1a721a390b9455b85f5ebb13ee36281.png', '.png', '2021-08-29 16:53:35.683000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (262, 'a890e9410f8a4373aca476ac9ecc234f.png', 'http://img.mrqinzh.info/a890e9410f8a4373aca476ac9ecc234f.png', '.png', '2021-08-30 12:11:25.520000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (263, 'c04d9e0695434e199aa5f36451a1c8e2.png', 'http://img.mrqinzh.info/c04d9e0695434e199aa5f36451a1c8e2.png', '.png', '2021-08-30 12:11:44.802000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (264, 'd89f42ad1f254bcba4814fa9ea9c074d.png', 'http://img.mrqinzh.info/d89f42ad1f254bcba4814fa9ea9c074d.png', '.png', '2021-08-30 15:36:38.289000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (265, 'ef63f5a983274fe2b6449ecfae5554bc.png', 'http://img.mrqinzh.info/ef63f5a983274fe2b6449ecfae5554bc.png', '.png', '2021-08-30 15:37:14.633000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (266, '2d2dc86864f247feb13c5ea7a63659d2.png', 'http://img.mrqinzh.info/2d2dc86864f247feb13c5ea7a63659d2.png', '.png', '2021-08-31 10:35:59.600000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (267, '781a6f27d8a14f1d9ae6aa8ccff19373.png', 'http://img.mrqinzh.info/781a6f27d8a14f1d9ae6aa8ccff19373.png', '.png', '2021-08-31 10:36:21.435000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (268, 'eee6d2486b674a8d87d484939a7718b5.png', 'http://img.mrqinzh.info/eee6d2486b674a8d87d484939a7718b5.png', '.png', '2021-08-31 11:14:21.488000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (269, '8038d9e00ef74c98b6590c2261f79189.png', 'http://img.mrqinzh.info/8038d9e00ef74c98b6590c2261f79189.png', '.png', '2021-09-01 11:26:42.539000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (270, 'c3aba76bb2a14eaf867fe0e52cce440b.png', 'http://img.mrqinzh.info/c3aba76bb2a14eaf867fe0e52cce440b.png', '.png', '2021-09-06 16:37:58.290000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (271, '0018f77d14384f38b41937bfb774a6e1.png', 'http://img.mrqinzh.info/0018f77d14384f38b41937bfb774a6e1.png', '.png', '2021-09-06 16:41:01.577000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (272, 'd95a068d3d4146dcacda734836e219bd.png', 'http://img.mrqinzh.info/d95a068d3d4146dcacda734836e219bd.png', '.png', '2021-09-08 15:43:10.082000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (273, '261fcbdfb70b4f71a288913a8f89ecba.jpg', 'http://img.mrqinzh.info/261fcbdfb70b4f71a288913a8f89ecba.jpg', '.jpg', '2021-11-03 16:29:21.355000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (274, 'ce41c69ae647495a8dd1bb34a6553255.png', 'http://img.mrqinzh.info/ce41c69ae647495a8dd1bb34a6553255.png', '.png', '2021-11-03 16:29:50.245000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (275, 'f5ea46516caa42feac16b850ef6177bd.png', 'http://img.mrqinzh.info/f5ea46516caa42feac16b850ef6177bd.png', '.png', '2021-11-03 16:30:20.700000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (276, '15dde3ee231d496795a54d8fa6b6eca2.png', 'http://img.mrqinzh.info/15dde3ee231d496795a54d8fa6b6eca2.png', '.png', '2021-11-03 16:32:30.934000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (277, 'de81ad55c0a74fe5853252637b29c018.png', 'http://img.mrqinzh.info/de81ad55c0a74fe5853252637b29c018.png', '.png', '2021-11-03 16:38:32.056000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (278, 'b1c7a6de6abf4512a76dae5c1ad52f98.png', 'http://img.mrqinzh.info/b1c7a6de6abf4512a76dae5c1ad52f98.png', '.png', '2021-11-04 15:06:09.904000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (279, '6d4765a5368d4cec97c8f15edad6bc01.png', 'http://img.mrqinzh.info/6d4765a5368d4cec97c8f15edad6bc01.png', '.png', '2021-11-04 15:08:18.265000', NULL, '七牛云', 0);
INSERT INTO `file` (`id`, `file_name`, `file_path`, `file_type`, `file_create_time`, `file_size`, `file_place`, `status`) VALUES (280, 'b4a010846e1b45fe8e8e724612df21b2.png', 'http://img.mrqinzh.info/b4a010846e1b45fe8e8e724612df21b2.png', '.png', '2021-11-04 15:10:12.182000', NULL, '七牛云', 0);
COMMIT;

-- ----------------------------
-- Table structure for SYS_CONFIG
-- ----------------------------
DROP TABLE IF EXISTS `SYS_CONFIG`;
CREATE TABLE `SYS_CONFIG` (
                              `id` bigint NOT NULL,
                              `configKey` varchar(255) DEFAULT NULL,
                              `configValue` varchar(255) DEFAULT NULL,
                              `createTime` datetime DEFAULT NULL,
                              `updateTime` datetime DEFAULT NULL,
                              PRIMARY KEY (`id` DESC) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of SYS_CONFIG
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu` (
                            `id` bigint NOT NULL AUTO_INCREMENT,
                            `parentId` bigint NOT NULL DEFAULT '0',
                            `menuTitle` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '菜单名',
                            `componentName` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '组件名',
                            `componentPath` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '组件位置',
                            `redirect` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
                            `icon` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '图标',
                            `menuPath` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '菜单路径',
                            `cache` int NOT NULL DEFAULT '0' COMMENT '是否缓存 0：缓存 1：不缓存',
                            `hidden` int NOT NULL DEFAULT '1' COMMENT '是否隐藏 0：隐藏 1：不隐藏',
                            `menuSort` int DEFAULT NULL,
                            `type` int DEFAULT NULL,
                            `permission` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
                            `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                            `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                            `status` int NOT NULL DEFAULT '0' COMMENT '0：未删 1：已删',
                            PRIMARY KEY (`id`,`parentId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
BEGIN;
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (3, 0, '权限管理', 'Authority', 'Layout', 'noRedirect', 'el-icon-medal', '/admin/authority', 1, 1, 1, NULL, NULL, '2021-10-26 15:26:23', '2021-10-29 11:20:31', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (4, 3, '菜单管理', 'Menu', 'authority/menu/', NULL, 'el-icon-s-operation', '/admin/authority/menu', 1, 1, 3, NULL, NULL, '2021-10-26 14:58:28', '2021-10-29 13:30:38', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (5, 3, '角色管理', 'Role', 'authority/role/', NULL, 'el-icon-user-solid', '/admin/authority/role', 1, 1, 2, NULL, NULL, '2021-10-26 14:58:29', '2021-10-29 13:30:47', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (8, 0, '系统管理', 'System', 'Layout', NULL, 'el-icon-data-board', '/admin/system', 1, 1, 2, NULL, NULL, '2021-10-29 11:09:27', '2021-10-29 11:09:27', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (9, 3, '用户管理', 'User', 'system/user/User', NULL, 'el-icon-s-custom', '/admin/authority/user', 0, 1, 1, NULL, NULL, '2021-10-29 11:15:52', '2021-10-29 11:17:15', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (10, 8, '评论管理', 'Comment', 'system/comment/Comment', NULL, 'el-icon-chat-line-round', '/admin/system/comment', 1, 1, 2, NULL, NULL, '2021-10-29 11:24:08', '2021-10-29 14:05:37', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (11, 8, '文章管理', 'Article', 'system/article/index', NULL, 'el-icon-reading', '/admin/system/article', 1, 1, 1, NULL, NULL, '2021-10-29 13:38:37', '2021-10-29 13:38:37', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (12, 11, '文章列表', 'ArticleList', 'system/article/Article', NULL, 'el-icon-menu', '/admin/system/article/list', 1, 1, 1, NULL, NULL, '2021-10-29 13:40:33', '2021-10-29 15:41:36', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (13, 8, '标签管理', 'Tag', 'system/tag/index', NULL, 'el-icon-collection-tag', '/admin/system/tag', 0, 1, 3, NULL, NULL, '2021-10-29 14:05:21', '2021-10-29 14:05:21', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (14, 11, '写文章', 'ArticleAdd', 'system/article/add_copy', NULL, 'el-icon-edit', '/admin/system/article/add', 0, 1, 2, NULL, NULL, '2021-10-29 15:42:52', '2021-10-29 15:44:21', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (15, 0, '图标库', 'Icons', 'Layout', '', 'el-icon-star-on', '/icon/index', 0, 1, 3, NULL, NULL, '2021-10-29 16:32:45', '2021-10-29 16:32:45', 1);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (17, 0, '邮件', 'Email', 'Layout', NULL, 'el-icon-s-promotion', '/email/index', 0, 1, 4, NULL, NULL, '2021-10-29 16:32:46', '2021-10-29 16:32:46', 1);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (18, 0, '个人中心', 'Account', 'Layout', NULL, 'el-icon-s-custom', '/account', 0, 0, 5, NULL, NULL, '2021-11-03 15:26:59', '2021-11-03 15:31:24', 0);
INSERT INTO `sys_menu` (`id`, `parentId`, `menuTitle`, `componentName`, `componentPath`, `redirect`, `icon`, `menuPath`, `cache`, `hidden`, `menuSort`, `type`, `permission`, `createTime`, `updateTime`, `status`) VALUES (19, 18, '个人页', 'Center', 'account/center/', NULL, 'el-icon-s-custom', '/account/center', 0, 1, 5, NULL, NULL, '2021-11-03 15:28:16', '2021-11-03 15:28:16', 0);
COMMIT;

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role` (
                            `id` bigint NOT NULL AUTO_INCREMENT,
                            `roleName` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '角色名称',
                            `createTime` datetime DEFAULT NULL,
                            `updateTime` datetime DEFAULT NULL,
                            `status` int NOT NULL DEFAULT '0',
                            PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
BEGIN;
INSERT INTO `sys_role` (`id`, `roleName`, `createTime`, `updateTime`, `status`) VALUES (1, 'super-admin', '2021-10-20 20:52:51', '2021-10-20 20:52:54', 0);
INSERT INTO `sys_role` (`id`, `roleName`, `createTime`, `updateTime`, `status`) VALUES (2, 'admin', '2021-10-20 20:53:03', '2021-10-20 20:53:00', 0);
INSERT INTO `sys_role` (`id`, `roleName`, `createTime`, `updateTime`, `status`) VALUES (3, 'user', '2021-10-20 20:53:06', '2021-10-20 20:53:09', 0);
COMMIT;

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu` (
                                 `id` bigint NOT NULL AUTO_INCREMENT,
                                 `roleId` bigint NOT NULL COMMENT '角色id',
                                 `menuId` bigint NOT NULL COMMENT '菜单id',
                                 `createTime` datetime DEFAULT NULL,
                                 `updateTime` datetime DEFAULT NULL,
                                 `status` int NOT NULL DEFAULT '0',
                                 PRIMARY KEY (`id`,`roleId`,`menuId`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role` (
                                 `id` bigint NOT NULL AUTO_INCREMENT,
                                 `userId` bigint NOT NULL COMMENT '用户id',
                                 `roleId` bigint NOT NULL COMMENT '角色id',
                                 `createTime` datetime DEFAULT NULL,
                                 `updateTime` datetime DEFAULT NULL,
                                 `status` int NOT NULL DEFAULT '0' COMMENT '逻辑删除',
                                 PRIMARY KEY (`id`,`userId`,`roleId`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for t_login_log
-- ----------------------------
DROP TABLE IF EXISTS `t_login_log`;
CREATE TABLE `t_login_log` (
                               `id` bigint NOT NULL AUTO_INCREMENT,
                               `userId` bigint NOT NULL,
                               `token` varchar(250) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT '',
                               `ip` varchar(200) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
                               `createTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
                               `updateTime` datetime DEFAULT NULL,
                               PRIMARY KEY (`id`,`userId`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of t_login_log
-- ----------------------------
BEGIN;
INSERT INTO `t_login_log` (`id`, `userId`, `token`, `ip`, `createTime`, `updateTime`) VALUES (1, 1, 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwYXNzd29yZCI6IjEiLCJpc3MiOiJhdXRoMCIsImF2YXRhciI6Imh0dHA6Ly9tcnFpbnpoLmluZm86OTA5MC9pbWcvYXZhdGFyLmpwZyIsImV4cCI6MTYyOTcwNTQ2MCwidXNlcm5hbWUiOiJhZG1pbiJ9.6YbDjXX8hxWGJk2xZ-v8sCBGYUr7BLmsN6zduMk2Iyg', '127.0.0.1', '2021-08-23 14:57:41', NULL);
COMMIT;

-- ----------------------------
-- Table structure for t_message
-- ----------------------------
DROP TABLE IF EXISTS `t_message`;
CREATE TABLE `t_message` (
                             `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
                             `avatar` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '头像',
                             `nickname` varchar(20) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '昵称',
                             `content` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '留言内容',
                             `time` tinyint(1) DEFAULT NULL COMMENT '弹幕速度',
                             `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
                             `ip` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '远程ip',
                             `status` int NOT NULL DEFAULT '0' COMMENT '0: 正常    1: 删除',
                             `updateTime` datetime DEFAULT NULL,
                             PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of t_message
-- ----------------------------
BEGIN;
INSERT INTO `t_message` (`id`, `avatar`, `nickname`, `content`, `time`, `createTime`, `ip`, `status`, `updateTime`) VALUES (10, 'http://mrqinzh.info:9090/img/avatar.jpg', 'mrqinzh', '留言功能上线', 10, '2021-09-17 11:03:29', '202.98.63.138', 0, NULL);
INSERT INTO `t_message` (`id`, `avatar`, `nickname`, `content`, `time`, `createTime`, `ip`, `status`, `updateTime`) VALUES (11, 'http://mrqinzh.info:9090/img/random-avatars/avatar7.png', '陈博', '牛牛牛', 9, '2021-09-17 12:11:50', '202.98.63.138', 0, NULL);
INSERT INTO `t_message` (`id`, `avatar`, `nickname`, `content`, `time`, `createTime`, `ip`, `status`, `updateTime`) VALUES (12, 'http://mrqinzh.info:9090/img/random-avatars/avatar10.png', '世界无敌美少女', '秦志宏是猪猪', 8, '2021-09-19 18:43:53', '183.226.63.12', 0, NULL);
COMMIT;

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
                       `id` bigint NOT NULL AUTO_INCREMENT,
                       `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '标签名称',
                       `coverImg` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '标签图片',
                       `createTime` datetime DEFAULT NULL,
                       `updateTime` datetime DEFAULT NULL,
                       PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of tag
-- ----------------------------
BEGIN;
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (1, 'Java', 'http://img.mrqinzh.info/java.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (2, 'Spring', 'http://img.mrqinzh.info/spring.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (3, '面试', NULL, NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (4, '源码', NULL, NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (5, '算法', NULL, NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (6, '设计模式', NULL, NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (7, 'mysql', 'http://img.mrqinzh.info/mysql.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (8, '数据库', NULL, NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (9, 'HTML', 'http://img.mrqinzh.info/html.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (10, 'CSS', 'http://img.mrqinzh.info/css.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (11, 'JavaScript', 'http://img.mrqinzh.info/js.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (12, 'Vue', 'http://img.mrqinzh.info/vue.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (13, 'Element-UI', 'http://img.mrqinzh.info/element-ui.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (14, 'LayUI', NULL, NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (15, 'SpringBoot', 'http://img.mrqinzh.info/springboot.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (16, 'Mybatis', NULL, NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (17, 'Mybatis-Plus', NULL, NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (18, '生活', NULL, NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (19, '其他', '', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (20, 'JVM', 'http://img.mrqinzh.info/jvm.png', NULL, NULL);
INSERT INTO `tag` (`id`, `name`, `coverImg`, `createTime`, `updateTime`) VALUES (25, 'ZooKeeper', 'http://img.mrqinzh.info/6d4765a5368d4cec97c8f15edad6bc01.png', NULL, NULL);
COMMIT;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
                        `id` bigint NOT NULL AUTO_INCREMENT,
                        `roleName` varchar(20) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
                        `mobile` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '电话号码',
                        `loginLastTime` datetime DEFAULT NULL COMMENT '最后登录时间',
                        `avatar` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '头像',
                        `nickname` varchar(20) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '显示名称',
                        `email` varchar(20) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '邮箱',
                        `realName` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '用户真实姓名',
                        `username` varchar(20) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '用户名',
                        `pwd` varchar(20) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '密码',
                        `createTime` datetime DEFAULT NULL,
                        `updateTime` datetime DEFAULT NULL,
                        PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------
BEGIN;
INSERT INTO `user` (`id`, `roleName`, `mobile`, `loginLastTime`, `avatar`, `nickname`, `email`, `realName`, `username`, `pwd`, `createTime`, `updateTime`) VALUES (1, 'super-admin', '15730567860', '2021-08-07 17:33:14', 'http://mrqinzh.info:9090/img/avatar.jpg', 'mrqinzh', '1552589784@qq.com', '秦志宏', 'admin', '1', NULL, NULL);
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
